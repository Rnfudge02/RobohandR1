=== PROJECT STRUCTURE ===
./Include/Core/Scheduler/log_manager.h
./Include/Core/Scheduler/scheduler.h
./Include/Core/Scheduler/scheduler_mpu_tz.h
./Include/Core/Scheduler/scheduler_tz.h
./Include/Core/Scheduler/sensor_manager_init.h
./Include/Core/Scheduler/system_init.h
./Include/Core/Shell/hardware_stats_shell_commands.h
./Include/Core/Shell/scheduler_shell_commands.h
./Include/Core/Shell/sensor_manager_shell_commands.h
./Include/Core/Shell/stats_shell_commands.h
./Include/Core/Shell/usb_shell.h
./Include/Core/Stats/hardware_stats.h
./Include/Core/Stats/mem_usage.h
./Include/Core/Stats/stats.h
./Src/Core/Scheduler/fault_handlers.c
./Src/Core/Scheduler/log_manager.c
./Src/Core/Scheduler/scheduler.c
./Src/Core/Scheduler/scheduler_mpu_tz.c
./Src/Core/Scheduler/scheduler_tz.c
./Src/Core/Scheduler/sensor_manager_init.c
./Src/Core/Scheduler/system_init.c
./Src/Core/Shell/hardware_stats_shell_commands.c
./Src/Core/Shell/scheduler_shell_commands.c
./Src/Core/Shell/sensor_manager_shell_commands.c
./Src/Core/Shell/stats_shell_commands.c
./Src/Core/Shell/usb_shell.c
./Src/Core/Stats/hardware_stats.c
./Src/Core/Stats/mem_usage.c
./Src/Core/Stats/stats.c

=== CODE CONTENT ===

// File: ./Include/Core/Scheduler/log_manager.h
/**
* @file log_manager.h
* @brief Robust logging system with multi-destination support
* @author Based on Robert Fudge's work
* @date 2025-05-14
*/

#ifndef LOG_MANAGER_H
#define LOG_MANAGER_H

#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include "pico/stdlib.h"
#include "hardware/sync.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Log severity levels
 */
typedef enum {
    LOG_LEVEL_TRACE = 0,  // Most verbose - detailed tracing
    LOG_LEVEL_DEBUG,      // Debug information
    LOG_LEVEL_INFO,       // General information
    LOG_LEVEL_WARN,       // Warning conditions
    LOG_LEVEL_ERROR,      // Error conditions
    LOG_LEVEL_FATAL,      // Fatal errors
    LOG_LEVEL_NONE        // No logging
} log_level_t;

/**
 * @brief Log output destinations
 */
typedef enum {
    LOG_DEST_CONSOLE = 0x01,  // Output to console (USB/UART)
    LOG_DEST_SDCARD  = 0x02,  // Output to SD card
    LOG_DEST_FLASH   = 0x04,  // Output to flash memory
    LOG_DEST_ALL     = 0xFF   // Output to all available destinations
} log_destination_t;

/**
 * @brief Log message structure
 */
typedef struct {
    absolute_time_t timestamp;  // Message timestamp
    log_level_t level;          // Message severity level
    uint8_t core_id;            // Core ID (0 or 1)
    const char* module;         // Source module name
    const char* message;        // Log message
    uint32_t seq_num;           // Sequence number for ordering
} log_message_t;

/**
 * @brief Logger configuration
 */
typedef struct {
    log_level_t console_level;      // Minimum level for console output
    log_level_t sdcard_level;       // Minimum level for SD card output
    log_level_t flash_level;        // Minimum level for flash output
    uint32_t buffer_size;           // Size of internal message buffer
    uint32_t max_message_size;      // Maximum size of a log message
    const char* sdcard_filename;    // Filename for SD card logging
    uint32_t flash_offset;          // Starting offset in flash for logging
    uint32_t flash_size;            // Size of flash region for logging
    bool include_timestamp;         // Include timestamp in messages
    bool include_level;             // Include level in messages
    bool include_core_id;           // Include core ID in messages
    bool color_output;              // Use ANSI colors in console output
} log_config_t;

/**
 * @brief Initialize the logging system
 * 
 * @param config Logging configuration
 * @return true if initialization successful
 * @return false if initialization failed
 */
bool log_init(const log_config_t* config);

/**
 * @brief Get default logging configuration
 * 
 * @param config Pointer to config structure to fill
 */
void log_get_default_config(log_config_t* config);

/**
 * @brief Set the global logging level
 * 
 * @param level Minimum level to log
 * @param destination Destination(s) to apply level to
 */
void log_set_level(log_level_t level, log_destination_t destination);

/**
 * @brief Add a log message to the buffer
 * 
 * @param level Log severity level
 * @param module Source module name
 * @param format Format string (printf style)
 * @param ... Variable arguments
 */
void log_message(log_level_t level, const char* module, const char* format, ...);

/**
 * @brief Process and output pending log messages
 * 
 * @note This should be called regularly to flush the log buffer
 */
void log_process(void);

/**
 * @brief Flush all pending log messages
 * 
 * @note This ensures all buffered messages are written to their destinations
 */
void log_flush(void);

/**
 * @brief Set log output destinations
 * 
 * @param destinations Bitmask of destinations (LOG_DEST_*)
 */
void log_set_destinations(uint8_t destinations);

/**
 * @brief Convenience macros for logging
 */
#define LOG_TRACE(module, ...) log_message(LOG_LEVEL_TRACE, module, __VA_ARGS__)
#define LOG_DEBUG(module, ...) log_message(LOG_LEVEL_DEBUG, module, __VA_ARGS__)
#define LOG_INFO(module, ...)  log_message(LOG_LEVEL_INFO, module, __VA_ARGS__)
#define LOG_WARN(module, ...)  log_message(LOG_LEVEL_WARN, module, __VA_ARGS__)
#define LOG_ERROR(module, ...) log_message(LOG_LEVEL_ERROR, module, __VA_ARGS__)
#define LOG_FATAL(module, ...) log_message(LOG_LEVEL_FATAL, module, __VA_ARGS__)

/**
 * @brief Get module name from filename
 */
#define LOG_MODULE_NAME (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : \
                         (strrchr(__FILE__, '\\') ? strrchr(__FILE__, '\\') + 1 : __FILE__))

#ifdef __cplusplus
}
#endif

#endif // LOG_MANAGER_H
// File: ./Include/Core/Scheduler/scheduler.h
/**
* @file scheduler.h
* @brief Multi-core cooperative/preemptive scheduler for Raspberry Pi Pico 2W
* @author [Robert Fudge (rnfudge@mun.ca)]
* @date [Current Date]
* @version 1.0
* 
* This scheduler provides both cooperative and preemptive multitasking with 
* dual-core support, priority-based scheduling, and proper synchronization 
* between cores. It supports both one-shot and persistent tasks.
* 
* @section features Features
* - Dual-core support (RP2040/RP2350)
* - Priority-based scheduling (5 levels)
* - Task types: one-shot and persistent
* - Core affinity settings
* - Thread-safe operations
* - Runtime statistics
* 
* @section usage Basic Usage
* @code
* //Initialize scheduler
* scheduler_init();
* 
* //Create a persistent task (runs forever)
* scheduler_create_task(my_task, NULL, 0, TASK_PRIORITY_NORMAL, 
*                      "mytask", 0, TASK_TYPE_PERSISTENT);
* 
* //Start scheduler
* scheduler_start();
* 
* //Main loop
* while(1) {
*     scheduler_run_pending_tasks();
* }
* @endcode
*/

#ifndef SCHEDULER_H
#define SCHEDULER_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "hardware/sync.h"

/**
 * @defgroup scheduler_constants Scheduler Configuration Constants
 * @{
 */

/** Maximum number of tasks per core */
#define MAX_TASKS 16

/** Default stack size per task (in 32-bit words) */
#define STACK_SIZE 2048

/** Maximum task name length including null terminator */
#define TASK_NAME_LEN 16

/** @} */

/**
 * @enum task_state_t
 * @brief Task states in the scheduler lifecycle
 * 
 * Tasks transition through these states during execution.
 * The scheduler uses these states to determine which tasks to run.
 */
typedef enum {
    TASK_STATE_INACTIVE = 0,  /**< Task slot is empty/unused */
    TASK_STATE_READY,         /**< Task is ready to be scheduled */
    TASK_STATE_RUNNING,       /**< Task is currently executing */
    TASK_STATE_BLOCKED,       /**< Task is waiting for a resource */
    TASK_STATE_SUSPENDED,     /**< Task is temporarily suspended */
    TASK_STATE_COMPLETED      /**< Task has finished execution */
} task_state_t;

/**
 * @enum task_priority_t
 * @brief Task priority levels
 * 
 * Higher priority tasks preempt lower priority tasks.
 * Tasks of equal priority are scheduled round-robin.
 */
typedef enum {
    TASK_PRIORITY_IDLE = 0,   /**< Lowest priority - runs when system idle */
    TASK_PRIORITY_LOW,        /**< Low priority background tasks */
    TASK_PRIORITY_NORMAL,     /**< Default priority for most tasks */
    TASK_PRIORITY_HIGH,       /**< High priority tasks (e.g., UI) */
    TASK_PRIORITY_CRITICAL    /**< Highest priority - time critical tasks */
} task_priority_t;

/**
 * @enum task_type_t
 * @brief Task execution behavior types
 * 
 * Determines how the scheduler handles task completion.
 */
typedef enum {
    TASK_TYPE_ONESHOT,        /**< Task runs once then completes */
    TASK_TYPE_PERSISTENT      /**< Task runs indefinitely */
} task_type_t;

/**
 * @typedef task_func_t
 * @brief Task function prototype
 * 
 * All task functions must conform to this signature.
 * 
 * @param params User-defined parameters passed to the task
 */
typedef void (*task_func_t)(void *params);

/**
 * @struct task_control_block_t
 * @brief Task Control Block (TCB) with TrustZone support
 * 
 * Contains all information needed to manage a task including
 * its context, state, scheduling parameters, and statistics.
 */
typedef struct {
    uint32_t *stack_ptr;              /**< Current stack pointer */
    uint32_t *stack_base;             /**< Base address of task stack */
    uint32_t stack_size;              /**< Stack size in 32-bit words */
    task_state_t state;               /**< Current task state */
    task_priority_t priority;         /**< Task priority level */
    task_func_t function;             /**< Task entry point function */
    void *params;                     /**< Parameters passed to task */
    char name[TASK_NAME_LEN];         /**< Task name for debugging */
    uint32_t task_id;                 /**< Unique task identifier */
    uint8_t core_affinity;            /**< Core assignment (0, 1, or 0xFF for any) */
    task_type_t type;                 /**< Task execution type */
    uint32_t run_count;               /**< Number of times task has run */
    uint64_t total_runtime;           /**< Total execution time in microseconds */
    uint64_t last_run_time;           /**< Timestamp of last execution */
    bool mpu_enabled;                 /**< Whether MPU protection is enabled */
    bool is_secure;                   /**< Whether task runs in secure state */
    uint32_t fault_count;             /**< Number of MPU/secure faults */
    char fault_reason[32];            /**< Last fault reason */
} task_control_block_t;

/**
 * @struct scheduler_stats_t
 * @brief Scheduler runtime statistics
 * 
 * Provides performance metrics and debugging information
 * about scheduler operation.
 */
typedef struct {
    uint32_t context_switches;        /**< Total number of context switches */
    uint32_t task_creates;            /**< Total tasks created */
    uint32_t task_deletes;            /**< Total tasks deleted */
    uint64_t total_runtime;           /**< Total scheduler runtime in microseconds */
    uint32_t core0_switches;          /**< Context switches on core 0 */
    uint32_t core1_switches;          /**< Context switches on core 1 */
} scheduler_stats_t;

/**
 * @struct core_sync_t
 * @brief Core synchronization structure
 * 
 * Manages thread-safe communication between CPU cores.
 */
typedef struct {
    uint task_list_lock_num;          /**< Spin lock for task list access */
    uint scheduler_lock_num;          /**< Spin lock for scheduler state */
    volatile bool core1_started;      /**< Flag indicating core 1 is running */
    volatile bool scheduler_running;  /**< Global scheduler running state */
} core_sync_t;

/**
 * @defgroup scheduler_api Scheduler API Functions
 * @{
 */

/**
 * @brief Initialize the scheduler
 * 
 * Sets up scheduler data structures, synchronization objects,
 * and prepares both cores for task execution.
 * 
 * @return true if initialization successful, false otherwise
 * 
 * @pre Must be called before any other scheduler functions
 * @post Scheduler is ready to accept tasks but not yet running
 * 
 * @code
 * if (!scheduler_init()) {
 *     printf("Scheduler initialization failed\n");
 *     return -1;
 * }
 * @endcode
 */
bool scheduler_init(void);

/**
 * @brief Start the scheduler
 * 
 * Begins task scheduling on both cores. Starts the scheduler timer
 * and launches core 1 execution.
 * 
 * @return true if scheduler started successfully, false otherwise
 * 
 * @pre scheduler_init() must have been called successfully
 * @post Scheduler is actively scheduling tasks
 */
bool scheduler_start(void);

/**
 * @brief Stop the scheduler
 * 
 * Halts task scheduling on both cores and stops the scheduler timer.
 * Running tasks are interrupted.
 * 
 * @post All task scheduling stops, core 1 is reset
 * 
 * @warning This function does not gracefully shutdown tasks
 */
void scheduler_stop(void);

/**
 * @brief Create a new task
 * 
 * Creates a task with specified parameters and adds it to the scheduler.
 * Tasks are created in READY state and will be scheduled based on priority.
 * 
 * @param function      Task entry point function
 * @param params        Parameters to pass to the task (can be NULL)
 * @param stack_size    Stack size in 32-bit words (0 for default)
 * @param priority      Task priority level
 * @param name          Task name for debugging (max 15 chars)
 * @param core_affinity Core to run on (0, 1, or 0xFF for any core)
 * @param type          Task type (ONESHOT or PERSISTENT)
 * 
 * @return Task ID on success (>0), -1 on failure
 * 
 * @pre Scheduler must be initialized
 * @post Task is created and ready to be scheduled
 * 
 * @code
 * int task_id = scheduler_create_task(
 *     sensor_task,              //Function
 *     &sensor_config,           //Parameters
 *     1024,                     //Stack size
 *     TASK_PRIORITY_NORMAL,     //Priority
 *     "sensor",                 //Name
 *     1,                        //Run on core 1
 *     TASK_TYPE_PERSISTENT      //Runs forever
 * );
 * @endcode
 */
int scheduler_create_task(task_func_t function, void *params, uint32_t stack_size,
    task_priority_t priority, const char *name, uint8_t core_affinity, task_type_t type);

/**
 * @brief Delete a task
 * 
 * Removes a task from the scheduler and frees its resources.
 * 
 * @param task_id Task ID to delete
 * @return true if task deleted successfully, false otherwise
 * 
 * @warning Cannot delete currently running task
 * @todo Implement this function
 */
bool scheduler_delete_task(int task_id);

/**
 * @brief Suspend a task
 * 
 * Temporarily prevents a task from being scheduled.
 * 
 * @param task_id Task ID to suspend
 * @return true if task suspended successfully, false otherwise
 * 
 * @post Task will not be scheduled until resumed
 * @todo Implement this function
 */
bool scheduler_suspend_task(int task_id);

/**
 * @brief Resume a suspended task
 * 
 * Makes a suspended task eligible for scheduling again.
 * 
 * @param task_id Task ID to resume
 * @return true if task resumed successfully, false otherwise
 * 
 * @pre Task must be in SUSPENDED state
 * @post Task returns to READY state
 * @todo Implement this function
 */
bool scheduler_resume_task(int task_id);

/**
 * @brief Yield CPU to other tasks
 * 
 * Current task voluntarily gives up remaining time slice.
 * Useful for cooperative multitasking.
 * 
 * @post Current task moved to READY, scheduler runs next task
 * 
 * @code
 * while (1) {
 *     do_work();
 *     scheduler_yield();  //Let other tasks run
 * }
 * @endcode
 */
void scheduler_yield(void);

/**
 * @brief Delay task execution
 * 
 * Suspends the current task for specified milliseconds.
 * Other tasks run during the delay period.
 * 
 * @param ms Milliseconds to delay
 * 
 * @note This is a blocking delay for the calling task only
 */
void scheduler_delay(uint32_t ms);

/**
 * @brief Get current task ID
 * 
 * Returns the ID of the currently executing task.
 * 
 * @return Current task ID, or -1 if called from non-task context
 */
int scheduler_get_current_task(void);

/**
 * @brief Get scheduler statistics
 * 
 * Retrieves runtime statistics about scheduler performance.
 * 
 * @param stats Pointer to statistics structure to fill
 * @return true if statistics retrieved successfully, false otherwise
 * 
 * @code
 * scheduler_stats_t stats;
 * if (scheduler_get_stats(&stats)) {
 *     printf("Context switches: %lu\n", stats.context_switches);
 * }
 * @endcode
 */
bool scheduler_get_stats(scheduler_stats_t *stats);

/**
 * @brief Get task information
 * 
 * Retrieves detailed information about a specific task.
 * 
 * @param task_id Task ID to query
 * @param tcb     Pointer to TCB structure to fill
 * @return true if task found and info retrieved, false otherwise
 */
bool scheduler_get_task_info(int task_id, task_control_block_t *tcb);

/**
 * @brief Enable/disable scheduler tracing
 * 
 * Controls verbose debug output from the scheduler.
 * Useful for debugging scheduling issues.
 * 
 * @param enable true to enable tracing, false to disable
 * 
 * @note Tracing may impact system performance
 */
void scheduler_enable_tracing(bool enable);

/**
 * @brief Run pending tasks on current core
 * 
 * Executes one iteration of scheduled tasks on the calling core.
 * Must be called regularly from the main loop.
 * 
 * @note This function is non-blocking
 * 
 * @code
 * while (1) {
 *     scheduler_run_pending_tasks();
 *     //Other main loop activities
 * }
 * @endcode
 */
void scheduler_run_pending_tasks(void);

/**
 * @brief Get the current task for a specific core
 * 
 * @param core Core number (0 or 1)
 * @return Pointer to current task, or NULL if no task running
 */
task_control_block_t* scheduler_get_current_task_ptr(uint8_t core);

/**
 * @brief Set the current task for a specific core
 * 
 * @param core Core number (0 or 1)
 * @param task Pointer to task to set as current
 * @return true if successful, false otherwise
 */
bool scheduler_set_current_task_ptr(uint8_t core, task_control_block_t* task);

/** @} */ //end of scheduler_api group

#ifdef __cplusplus
}
#endif

#endif //SCHEDULER_H
// File: ./Include/Core/Scheduler/scheduler_mpu_tz.h
/**
* @file scheduler_mpu_tz.h
* @brief Memory Protection Unit and TrustZone configuration for the scheduler
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025-05-13
* 
* This module provides configuration functions for setting up MPU regions
* and TrustZone security attributes for tasks running under the scheduler.
* It handles memory protection between tasks and cores on the RP2350.
*/

#ifndef SCHEDULER_MPU_TZ_H
#define SCHEDULER_MPU_TZ_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

/**
 * @brief Memory access permissions
 */
typedef enum {
    MPU_NO_ACCESS = 0,
    MPU_READ_ONLY = 1, 
    MPU_READ_WRITE = 2,
    MPU_READ_EXEC = 3,
    MPU_READ_WRITE_EXEC = 4
} mpu_access_t;

/**
 * @brief Memory region security attributes
 */
typedef enum {
    TZ_SECURE = 0,
    TZ_NON_SECURE = 1,
    TZ_NON_SECURE_CALLABLE = 2
} tz_security_t;

/**
 * @brief MPU region configuration structure
 */
typedef struct {
    void *start_addr;           /**< Region start address (must be aligned) */
    size_t size;                /**< Region size in bytes (must be power of 2) */
    mpu_access_t access;        /**< Access permissions */
    tz_security_t security;     /**< Security attributes */
    bool cacheable;             /**< Whether region is cacheable */
    bool bufferable;            /**< Whether writes can be buffered */
    bool shareable;             /**< Whether region is shareable between cores */
} mpu_region_config_t;

/**
 * @brief Task memory protection configuration
 */
typedef struct {
    uint32_t task_id;                      /**< Task ID to apply configuration to */
    mpu_region_config_t *regions;          /**< Array of region configurations */
    uint8_t region_count;                  /**< Number of regions in array */
} task_mpu_config_t;

/**
 * @brief Initialize the MPU and TrustZone for the scheduler
 * 
 * Sets up default configurations and prepares the MPU.
 * This should be called once during system initialization.
 * 
 * @return true if initialization successful
 * @return false if initialization failed
 */
bool scheduler_mpu_tz_init(void);

/**
 * @brief Configure MPU and TZ settings for a specific task
 * 
 * @param config Task MPU configuration
 * @return true if configuration successful
 * @return false if configuration failed
 */
bool scheduler_mpu_configure_task(const task_mpu_config_t *config);

/**
 * @brief Apply MPU settings before task execution
 * 
 * This function is called by the scheduler before switching to a task.
 * It applies the appropriate MPU and TZ settings for the task.
 * 
 * @param task_id ID of the task to apply settings for
 * @return true if settings applied successfully
 * @return false if settings could not be applied
 */
bool scheduler_mpu_apply_task_settings(uint32_t task_id);

/**
 * @brief Remove task-specific MPU settings
 * 
 * Reset MPU to default settings when task is not running.
 * 
 * @param task_id ID of the task to remove settings for
 * @return true if settings removed successfully
 * @return false if settings could not be removed
 */
bool scheduler_mpu_reset_task_settings(uint32_t task_id);

/**
 * @brief Create default MPU configuration for a task
 * 
 * Generates a sensible default MPU configuration for a task based on
 * its stack and code areas.
 * 
 * @param task_id Task ID to generate configuration for
 * @param stack_start Start of task's stack
 * @param stack_size Size of task's stack in bytes
 * @param code_start Start of task's code
 * @param code_size Size of task's code in bytes
 * @param config Output parameter to store generated configuration
 * @return true if configuration generated successfully
 * @return false if configuration could not be generated
 */
bool scheduler_mpu_create_default_config(uint32_t task_id, 
                                        void *stack_start, size_t stack_size,
                                        void *code_start, size_t code_size,
                                        task_mpu_config_t *config);

/**
 * @brief Get current task's MPU configuration
 * 
 * @param task_id Task ID to get configuration for
 * @param config Output parameter to store configuration
 * @return true if configuration retrieved successfully
 * @return false if configuration could not be retrieved
 */
bool scheduler_mpu_get_task_config(uint32_t task_id, task_mpu_config_t *config);

/**
 * @brief Check if address is accessible by the current task
 * 
 * @param addr Address to check
 * @param size Size of the memory region starting at addr
 * @param write_access Whether write access is required
 * @return true if address is accessible
 * @return false if address is not accessible
 */
bool scheduler_mpu_is_accessible(void *addr, size_t size, bool write_access);

#ifdef __cplusplus
}
#endif

#endif // SCHEDULER_MPU_TZ_H
// File: ./Include/Core/Scheduler/scheduler_tz.h
/**
* @file scheduler_tz.h
* @brief TrustZone security configuration for the scheduler
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025-05-13
* 
* This module provides TrustZone-specific configuration for tasks running
* under the scheduler, enabling secure/non-secure transitions and proper
* isolation between security domains.
*/

#ifndef SCHEDULER_TZ_H
#define SCHEDULER_TZ_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>
#include "scheduler.h"

/**
 * @brief Security state for tasks
 */
typedef enum {
    TASK_SECURITY_SECURE = 0,         /**< Task runs in secure state */
    TASK_SECURITY_NON_SECURE = 1,     /**< Task runs in non-secure state */
    TASK_SECURITY_TRANSITIONAL = 2    /**< Task may transition between secure/non-secure */
} task_security_state_t;

/**
 * @brief Secure function call definition
 */
typedef struct {
    const char *name;                 /**< Function name */
    void *secure_gateway;             /**< Secure gateway entry point */
    void *non_secure_callable;        /**< Non-secure callable function */
} secure_function_t;

/**
 * @brief TrustZone configuration for a task
 */
typedef struct {
    uint32_t task_id;                      /**< Task ID to apply configuration to */
    task_security_state_t security_state;  /**< Task security state */
    secure_function_t *secure_functions;   /**< Array of secure functions accessible to task */
    uint8_t function_count;                /**< Number of secure functions */
} task_tz_config_t;

/**
 * @brief Initialize TrustZone support for the scheduler
 * 
 * Sets up security configuration for the scheduler. This should be
 * called during system initialization before tasks start.
 * 
 * @return true if initialization successful
 * @return false if initialization failed or TrustZone not supported
 */
bool scheduler_tz_init(void);

/**
 * @brief Configure TrustZone settings for a specific task
 * 
 * @param config Task TrustZone configuration
 * @return true if configuration successful
 * @return false if configuration failed
 */
bool scheduler_tz_configure_task(const task_tz_config_t *config);

/**
 * @brief Apply TrustZone settings before task execution
 * 
 * This function is called by the scheduler before switching to a task.
 * It applies the appropriate TrustZone settings for the task's security state.
 * 
 * @param task_id ID of the task to apply settings for
 * @return true if settings applied successfully
 * @return false if settings could not be applied
 */
bool scheduler_tz_apply_task_settings(uint32_t task_id);

/**
 * @brief Reset TrustZone settings after task execution
 * 
 * This function is called by the scheduler after a task completes.
 * It resets TrustZone settings to a known good state.
 * 
 * @param task_id ID of the task that was executing
 * @return true if settings reset successfully
 * @return false if settings could not be reset
 */
bool scheduler_tz_reset_task_settings(uint32_t task_id);

/**
 * @brief Check if TrustZone is enabled and available
 * 
 * @return true if TrustZone is enabled
 * @return false if TrustZone is not enabled
 */
bool scheduler_tz_is_enabled(void);

/**
 * @brief Get current security state
 * 
 * @return Current security state (secure or non-secure)
 */
task_security_state_t scheduler_tz_get_security_state(void);

/**
 * @brief Register a secure function for non-secure access
 * 
 * Makes a secure function callable from non-secure code through
 * the appropriate gateway mechanisms.
 * 
 * @param name Function name
 * @param secure_function Pointer to secure function
 * @param non_secure_callable Pointer to non-secure callable version (generated)
 * @return true if registration successful
 * @return false if registration failed
 */
bool scheduler_tz_register_secure_function(const char *name, 
                                          void *secure_function,
                                          void **non_secure_callable);

#ifdef __cplusplus
}
#endif

#endif // SCHEDULER_TZ_H
// File: ./Include/Core/Scheduler/sensor_manager_init.h
/**
* @file sensor_manager_init.h
* @brief Sensor manager initialization and task management
* @date 2025-05-13
*/

#ifndef SENSOR_MANAGER_INIT_H
#define SENSOR_MANAGER_INIT_H

#include "sensor_manager.h"
#include <stdbool.h>

/**
 * @brief Initialize the sensor manager and register with scheduler
 * 
 * @return true if successful, false otherwise
 */
bool sensor_manager_init(void);

/**
 * @brief Get the global sensor manager instance
 * 
 * @return Sensor manager handle or NULL if not initialized
 */
sensor_manager_t sensor_manager_get_instance(void);

#endif // SENSOR_MANAGER_INIT_H
// File: ./Include/Core/Scheduler/system_init.h
/**
* @file system_init.h
* @brief System initialization and startup sequence management
* @author Based on Robert Fudge's work
* @date 2025-05-14
*/

#ifndef SYSTEM_INIT_H
#define SYSTEM_INIT_H

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief System initialization result codes
 */
typedef enum {
    SYS_INIT_OK = 0,              // Initialization successful
    SYS_INIT_ERROR_GENERAL,       // General error
    SYS_INIT_ERROR_SCHEDULER,     // Scheduler initialization failed
    SYS_INIT_ERROR_LOGGER,        // Logger initialization failed
    SYS_INIT_ERROR_SHELL,         // Shell initialization failed
    SYS_INIT_ERROR_SENSOR_MANAGER, // Sensor manager initialization failed
    SYS_INIT_ERROR_MPU_TZ,        // MPU/TrustZone initialization failed
    SYS_INIT_ERROR_HARDWARE       // Hardware initialization failed
} sys_init_result_t;

/**
 * @brief System initialization flags
 */
typedef enum {
    SYS_INIT_FLAG_NONE          = 0x00,
    SYS_INIT_FLAG_SHELL         = 0x01,  // Initialize shell
    SYS_INIT_FLAG_SENSORS       = 0x02,  // Initialize sensors
    SYS_INIT_FLAG_MPU_TZ        = 0x04,  // Initialize MPU/TrustZone
    SYS_INIT_FLAG_LOGGING       = 0x08,  // Initialize logging system
    SYS_INIT_FLAG_VERBOSE       = 0x10,  // Enable verbose output
    SYS_INIT_FLAG_WATCHDOG      = 0x20,  // Enable watchdog timer
    SYS_INIT_FLAG_DEFAULT       = 0x0B   // Default: Shell, Sensors, Logging
} sys_init_flags_t;

/**
 * @brief System initialization configuration
 */
typedef struct {
    sys_init_flags_t flags;         // Initialization flags
    uint32_t watchdog_timeout_ms;   // Watchdog timeout in milliseconds
    const char* app_name;           // Application name
    const char* app_version;        // Application version
} sys_init_config_t;

/**
 * @brief Initialize the system with custom configuration
 * 
 * @param config System initialization configuration
 * @return Initialization result code
 */
sys_init_result_t system_init(const sys_init_config_t* config);

/**
 * @brief Get default system initialization configuration
 * 
 * @param config Pointer to configuration structure to fill
 */
void system_init_get_default_config(sys_init_config_t* config);

/**
 * @brief Run the system main loop
 * 
 * @note This function never returns
 */
void system_run(void);

/**
 * @brief Register application commands with the shell
 * 
 * @note Called automatically during initialization if shell is enabled
 */
void system_register_commands(void);

/**
 * @brief Handle system shutdown
 * 
 * Performs cleanup and shutdown operations
 * 
 * @param restart If true, restart the system; otherwise, halt
 */
void system_shutdown(bool restart);

/**
 * @brief Get the time since system initialization
 * 
 * @return Time in milliseconds since initialization
 */
uint32_t system_get_uptime_ms(void);

/**
 * @brief Feed the watchdog to prevent system reset
 * 
 * @note Must be called regularly if watchdog is enabled
 */
void system_feed_watchdog(void);

#ifdef __cplusplus
}
#endif

#endif // SYSTEM_INIT_H
// File: ./Include/Core/Shell/hardware_stats_shell_commands.h
/**
* @file hardware_stats_shell_commands.h
* @brief Shell command interface for cache and FPU status
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025
* 
* Header file for the shell command interface that provides
* command-line interaction with cache and FPU stats functionality.
*/

#ifndef HARDWARE_STATS_SHELL_COMMANDS_H
#define HARDWARE_STATS_SHELL_COMMANDS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "usb_shell.h"

/**
 * @brief Handler function for the 'cachefpu' shell command
 * 
 * This function handles the 'cachefpu' shell command which displays
 * information about cache and FPU status.
 * 
 * @param argc Number of command line arguments
 * @param argv Array of command line argument strings
 * @return 0 on success, non-zero on error
 */
int cmd_cachefpu(int argc, char *argv[]);

/**
 * @brief Register cache and FPU commands with the shell
 * 
 * This function registers the cache and FPU related commands with the shell
 * system. It should be called during system initialization to make the
 * commands available.
 */
void register_cache_fpu_commands(void);

#ifdef __cplusplus
}
#endif

#endif // CACHE_FPU_SHELL_COMMANDS_H
// File: ./Include/Core/Shell/scheduler_shell_commands.h
/**
* @file scheduler_shell_commands.h
* @brief Shell commands for controlling the task scheduler
* @author [Robert Fudge (rnfudge@mun.ca)]
* @date [Current Date]
* @version 1.0
* 
* This module provides shell commands to control and monitor the
* multi-core task scheduler. It integrates the scheduler functionality
* with the USB shell interface.
* 
* @section commands Available Commands
* - scheduler: Start/stop/status of scheduler
* - task: Create and manage tasks
* - ps: List all tasks
* - stats: Show scheduler statistics
* - trace: Enable/disable tracing
*/

#ifndef SCHEDULER_SHELL_COMMANDS_H
#define SCHEDULER_SHELL_COMMANDS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "usb_shell.h"

/**
 * @defgroup scheduler_commands Scheduler Shell Commands
 * @{
 */

/**
 * @brief Scheduler control command
 * 
 * Controls the scheduler state and displays status information.
 * 
 * Usage: scheduler <start|stop|status>
 * 
 * @param argc Argument count
 * @param argv Argument array
 * @return 0 on success, 1 on error
 * 
 * @code
 * scheduler start    //Start the scheduler
 * scheduler stop     //Stop the scheduler
 * scheduler status   //Display scheduler status
 * @endcode
 */
int cmd_scheduler(int argc, char *argv[]);

/**
 * @brief Task management command
 * 
 * Creates test tasks with specified parameters.
 * 
 * Usage: task create <n> <priority> <core>
 * 
 * @param argc Argument count
 * @param argv Argument array
 * @return 0 on success, 1 on error
 * 
 * @code
 * task create 1 2 0    //Create task 1, priority 2, core 0
 * task create 2 3 -1   //Create task 2, priority 3, any core
 * @endcode
 */
int cmd_task(int argc, char *argv[]);

/**
 * @brief List all tasks command
 * 
 * Displays a table of all tasks with their current state,
 * priority, core affinity, and execution statistics.
 * 
 * Usage: ps
 * 
 * @param argc Argument count (unused)
 * @param argv Argument array (unused)
 * @return Always returns 0
 */
int cmd_ps(int argc, char *argv[]);

/**
 * @brief Show scheduler statistics
 * 
 * Displays detailed scheduler performance metrics including
 * context switches, runtime, and task counts.
 * 
 * Usage: stats
 * 
 * @param argc Argument count (unused)
 * @param argv Argument array (unused)
 * @return 0 on success, 1 on error
 */
int cmd_stats(int argc, char *argv[]);

/**
 * @brief Control scheduler tracing
 * 
 * Enables or disables verbose debug output from the scheduler.
 * Useful for debugging scheduling issues.
 * 
 * Usage: trace <on|off>
 * 
 * @param argc Argument count
 * @param argv Argument array
 * @return 0 on success, 1 on error
 * 
 * @code
 * trace on     //Enable debug output
 * trace off    //Disable debug output
 * @endcode
 */
int cmd_trace(int argc, char *argv[]);

/**
 * @brief Test task function for demonstrations
 * 
 * A sample task that runs for a specified number of iterations,
 * printing progress and demonstrating task switching.
 * 
 * @param params Task number as integer pointer
 * 
 * @note This task is created by the 'task create' command
 */
void test_task(void *params);

/**
 * @brief Register scheduler commands with the shell
 * 
 * Registers all scheduler-related commands with the USB shell.
 * Must be called after shell_init() but before entering main loop.
 * 
 * @pre Shell must be initialized
 * @post All scheduler commands are available in the shell
 * 
 * @code
 * shell_init();
 * register_scheduler_commands();
 * @endcode
 */
void register_scheduler_commands(void);

/** @} */ //end of scheduler_commands

#ifdef __cplusplus
}
#endif

#endif //SCHEDULER_SHELL_COMMANDS_H
// File: ./Include/Core/Shell/sensor_manager_shell_commands.h
/**
* @file sensor_manager_shell_commands.h
* @brief Shell commands for sensor manager
* @date 2025-05-13
*/

#ifndef SENSOR_MANAGER_SHELL_COMMANDS_H
#define SENSOR_MANAGER_SHELL_COMMANDS_H

#include "usb_shell.h"

/**
 * @brief Register all sensor manager commands with the shell
 */
void register_sensor_manager_commands(void);

/**
 * @brief Sensor manager command handler
 *
 * @param argc Argument count
 * @param argv Array of argument strings
 * @return 0 on success, non-zero on error
 */
int cmd_sensor(int argc, char *argv[]);

#endif // SENSOR_MANAGER_SHELL_COMMANDS_H
// File: ./Include/Core/Shell/stats_shell_commands.h
/**
* @file stats_shell_commands.h
* @brief Shell commands for statistics module
*/

#ifndef _STATS_SHELL_COMMANDS_H_
#define _STATS_SHELL_COMMANDS_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "usb_shell.h"

// Command handlers
int cmd_system_stats(int argc, char *argv[]);
int cmd_task_stats(int argc, char *argv[]);
int cmd_optimizations(int argc, char *argv[]);
int cmd_buffers(int argc, char *argv[]);
int cmd_stats_reset(int argc, char *argv[]);

// Register all stats commands with the shell
void register_stats_commands(void);

#ifdef __cplusplus
}
#endif

#endif /* _STATS_SHELL_COMMANDS_H_ */
// File: ./Include/Core/Shell/usb_shell.h
/**
* @file usb_shell.h
* @brief USB Command Line Shell Interface for Raspberry Pi Pico
* @author [Robert Fudge (rnfudge@mun.ca)]
* @date [Current Date]
* @version 1.0
* 
* This module provides a USB CDC-based command line interface with
* command parsing, argument handling, and extensible command registration.
* 
* @section features Features
* - USB CDC serial communication
* - Command parsing with argument support
* - Built-in commands (help, clear, echo)
* - Extensible command registration
* - Command history (optional)
* - Line editing with backspace support
* 
* @section usage Basic Usage
* @code
* //Initialize shell
* shell_init();
* 
* //Register custom commands
* shell_register_command(&my_command);
* 
* //Main loop
* while(1) {
*     shell_task();
* }
* @endcode
*/

#ifndef USB_SHELL_H
#define USB_SHELL_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>

/**
 * @defgroup shell_constants Shell Configuration Constants
 * @{
 */

/** Maximum command line buffer size */
#define SHELL_BUFFER_SIZE 256

/** Maximum number of arguments per command */
#define SHELL_MAX_ARGS 16

/** Shell prompt string */
#define SHELL_PROMPT "> "

/** @} */

/**
 * @struct shell_command_t
 * @brief Shell command structure
 * 
 * Defines a command with its name, help text, and handler function.
 * Commands are registered with the shell and matched against user input.
 */
typedef struct {
    const char *command;              /**< Command string that user types */
    const char *help;                 /**< Help text shown in help command */
    int (*handler)(int argc, char *argv[]); /**< Command handler function */
} shell_command_t;

/**
 * @struct shell_context_t
 * @brief Shell internal context
 * 
 * Maintains the state of the shell including input buffer,
 * parsed arguments, and configuration options.
 */
typedef struct {
    char buffer[SHELL_BUFFER_SIZE];   /**< Command input buffer */
    uint16_t buffer_pos;              /**< Current position in buffer */
    char *argv[SHELL_MAX_ARGS];       /**< Parsed argument pointers */
    int argc;                         /**< Number of parsed arguments */
    bool echo_enabled;                /**< Whether to echo input characters */
} shell_context_t;

/**
 * @defgroup shell_api Shell API Functions
 * @{
 */

/**
 * @brief Initialize the USB shell
 * 
 * Sets up the USB CDC interface, initializes shell data structures,
 * and registers built-in commands. Waits for USB connection before returning.
 * 
 * @pre USB stdio must be initialized (stdio_init_all())
 * @post Shell is ready to process commands
 * 
 * @code
 * stdio_init_all();
 * shell_init();
 * @endcode
 */
void shell_init(void);

/**
 * @brief Shell task - process input and execute commands
 * 
 * This function should be called repeatedly in the main loop.
 * It handles character input, command parsing, and execution.
 * The function is non-blocking if no input is available.
 * 
 * @note Call this as frequently as possible for responsive shell
 * 
 * @code
 * while (1) {
 *     shell_task();
 *     //Other tasks...
 * }
 * @endcode
 */
void shell_task(void);

/**
 * @brief Register a command with the shell
 * 
 * Adds a command to the shell's command table. The command will be
 * available immediately after registration.
 * 
 * @param cmd Pointer to command structure (must remain valid)
 * @return true if registration successful, false if command table full
 * 
 * @code
 * static const shell_command_t led_cmd = {
 *     "led",                    //Command
 *     "Control LED on/off",     //Help text
 *     cmd_led_handler          //Handler function
 * };
 * 
 * shell_register_command(&led_cmd);
 * @endcode
 */
bool shell_register_command(const shell_command_t *cmd);

/**
 * @defgroup shell_builtins Built-in Command Handlers
 * @{
 */

/**
 * @brief Help command handler
 * 
 * Displays list of all registered commands with their help text.
 * 
 * @param argc Argument count (unused)
 * @param argv Argument array (unused)
 * @return Always returns 0
 */
int cmd_help(int argc, char *argv[]);

/**
 * @brief Clear screen command handler
 * 
 * Clears the terminal screen using ANSI escape codes.
 * 
 * @param argc Argument count (unused)
 * @param argv Argument array (unused)
 * @return Always returns 0
 */
int cmd_clear(int argc, char *argv[]);

/**
 * @brief Echo command handler
 * 
 * Echoes all arguments back to the console.
 * 
 * @param argc Argument count
 * @param argv Argument array
 * @return Always returns 0
 * 
 * @code
 * //User types: echo Hello World
 * //Output: Hello World
 * @endcode
 */
int cmd_echo(int argc, char *argv[]);

/** @} */ //end of shell_builtins

/** @} */ //end of shell_api

#ifdef __cplusplus
}
#endif

#endif //USB_SHELL_H
// File: ./Include/Core/Stats/hardware_stats.h
/**
* @file hardware_stats.h
* @brief Header for RP2350 cache and FPU status detection
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025
* 
* Header file containing API for detecting and benchmarking
* cache and FPU functionality on the RP2350 processor.
*/

#ifndef HARDWARE_STATS_H
#define HARDWARE_STATS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

/**
 * @brief Structure containing cache and FPU statistics
 */
typedef struct {
    bool fpu_enabled;               /**< Whether FPU is enabled */
    bool icache_enabled;            /**< Whether instruction cache is enabled */
    bool dcache_enabled;            /**< Whether data cache is enabled */
    uint32_t fpu_benchmark_time;    /**< FPU benchmark execution time in microseconds */
    uint32_t cache_levels;          /**< Number of cache levels */
    uint32_t icache_line_size;      /**< Instruction cache line size in bytes */
    uint32_t dcache_line_size;      /**< Data cache line size in bytes */
} cache_fpu_stats_t;

/**
 * @brief Initialize the cache and FPU stats module
 * 
 * @return true if initialization successful
 * @return false if initialization failed
 */
bool cache_fpu_stats_init(void);

/**
 * @brief Check if FPU is enabled
 * 
 * @return true if FPU is enabled
 * @return false if FPU is disabled
 */
bool cache_fpu_is_fpu_enabled(void);

/**
 * @brief Check if instruction cache is enabled
 * 
 * @return true if instruction cache is enabled
 * @return false if instruction cache is disabled
 */
bool cache_fpu_is_icache_enabled(void);

/**
 * @brief Check if data cache is enabled
 * 
 * @return true if data cache is enabled
 * @return false if data cache is disabled
 */
bool cache_fpu_is_dcache_enabled(void);

/**
 * @brief Run a benchmark to test FPU performance
 * 
 * @return Benchmark execution time in microseconds
 */
uint32_t cache_fpu_benchmark_fpu(void);

/**
 * @brief Collect all cache and FPU statistics
 * 
 * @param stats Pointer to structure to store statistics
 */
void cache_fpu_get_stats(cache_fpu_stats_t* stats);

#ifdef __cplusplus
}
#endif

#endif // CACHE_FPU_STATS_H
// File: ./Include/Core/Stats/mem_usage.h

// File: ./Include/Core/Stats/stats.h
/**
* @file stats.h
* @brief System statistics module for tracking performance metrics
*/

#ifndef _STATS_H_
#define _STATS_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include "pico/stdlib.h"
#include "scheduler.h"

/**
 * @brief System optimization states
 */
typedef enum {
    OPT_NONE                    = 0x00,
    OPT_FREQUENCY_SCALING       = 0x01,
    OPT_VOLTAGE_SCALING         = 0x02,
    OPT_DMA_ENABLED            = 0x04,
    OPT_CACHE_ENABLED          = 0x08,
    OPT_MULTICORE_ENABLED      = 0x10,
    OPT_INTERRUPT_COALESCING   = 0x20,
    OPT_POWER_GATING           = 0x40,
    OPT_DOUBLE_BUFFERING       = 0x80
} optimization_state_t;

/**
 * @brief System operating statistics
 */
typedef struct {
    uint32_t system_freq_hz;        // Current system frequency
    uint32_t voltage_mv;            // Current voltage in millivolts
    uint32_t current_ma;            // Current draw in milliamps (if available)
    uint32_t temperature_c;         // Temperature in Celsius (if available)
    uint64_t uptime_us;            // System uptime in microseconds
    uint32_t free_heap_bytes;       // Available heap memory
    uint32_t used_heap_bytes;       // Used heap memory
    uint8_t cpu_usage_percent;      // Overall CPU usage percentage
    uint8_t core0_usage_percent;    // Core 0 usage percentage
    uint8_t core1_usage_percent;    // Core 1 usage percentage
} system_stats_t;

/**
 * @brief Task timing statistics
 */
typedef struct {
    uint32_t task_id;
    char task_name[TASK_NAME_LEN];
    uint32_t desired_period_us;     // Desired execution period
    uint32_t actual_period_us;      // Actual measured period
    uint32_t min_period_us;         // Minimum observed period
    uint32_t max_period_us;         // Maximum observed period
    uint32_t avg_execution_us;      // Average execution time
    uint32_t max_execution_us;      // Maximum execution time
    uint32_t deadline_misses;       // Number of deadline misses
    uint32_t total_executions;      // Total number of executions
    float jitter_percent;           // Period jitter percentage
} task_timing_stats_t;

/**
 * @brief Buffer registration structure for double buffering
 */
typedef struct {
    const char *name;               // Buffer name
    void *buffer_a;                 // First buffer
    void *buffer_b;                 // Second buffer
    size_t buffer_size;             // Size of each buffer
    volatile void **active_buffer;  // Pointer to currently active buffer
    uint32_t swap_count;            // Number of buffer swaps
    uint64_t last_swap_time_us;     // Time of last swap
    bool is_registered;             // Registration status
} buffer_registration_t;

/**
 * @brief Optimization suggestion based on stats
 */
typedef struct {
    optimization_state_t optimization;
    const char *description;
    uint8_t priority;  // 0-10, higher is more important
    float expected_improvement_percent;
} optimization_suggestion_t;

// Maximum number of registered buffers
#define MAX_REGISTERED_BUFFERS 16

// Maximum number of tasks to track
#define MAX_TASK_STATS 32

// Function prototypes

/**
 * @brief Initialize the statistics module
 * @return true on success, false on failure
 */
bool stats_init(void);

/**
 * @brief Get current system statistics
 * @param stats Output structure for system stats
 * @return true on success, false on failure
 */
bool stats_get_system(system_stats_t *stats);

/**
 * @brief Get task timing statistics
 * @param task_id ID of the task to query
 * @param stats Output structure for task stats
 * @return true on success, false on failure
 */
bool stats_get_task_timing(uint32_t task_id, task_timing_stats_t *stats);

/**
 * @brief Get all task timing statistics
 * @param stats Array to store timing stats
 * @param max_tasks Maximum number of tasks to retrieve
 * @return Number of tasks retrieved
 */
int stats_get_all_task_timing(task_timing_stats_t *stats, int max_tasks);

/**
 * @brief Update task timing statistics
 * @param task_id Task ID
 * @param execution_time_us Execution time in microseconds
 * @return true on success, false on failure
 */
bool stats_update_task_timing(uint32_t task_id, uint32_t execution_time_us);

/**
 * @brief Get current optimization state
 * @return Bitmask of active optimizations
 */
optimization_state_t stats_get_optimizations(void);

/**
 * @brief Set optimization state
 * @param opt Optimization to enable/disable
 * @param enabled true to enable, false to disable
 * @return true on success, false on failure
 */
bool stats_set_optimization(optimization_state_t opt, bool enabled);

/**
 * @brief Get optimization suggestions based on current stats
 * @param suggestions Array to store suggestions
 * @param max_suggestions Maximum number of suggestions to retrieve
 * @return Number of suggestions provided
 */
int stats_get_optimization_suggestions(optimization_suggestion_t *suggestions, int max_suggestions);

/**
 * @brief Register a double buffer for monitoring
 * @param name Buffer name
 * @param buffer_a First buffer
 * @param buffer_b Second buffer
 * @param size Size of each buffer
 * @param active_buffer Pointer to the active buffer pointer
 * @return Buffer registration ID on success, -1 on failure
 */
int stats_register_buffer(const char *name, void *buffer_a, void *buffer_b, 
                         size_t size, volatile void **active_buffer);

/**
 * @brief Get buffer statistics
 * @param buffer_id Buffer registration ID
 * @param reg Output structure for buffer info
 * @return true on success, false on failure
 */
bool stats_get_buffer_info(int buffer_id, buffer_registration_t *reg);

/**
 * @brief Get all registered buffers
 * @param buffers Array to store buffer info
 * @param max_buffers Maximum number of buffers to retrieve
 * @return Number of buffers retrieved
 */
int stats_get_all_buffers(buffer_registration_t *buffers, int max_buffers);

/**
 * @brief Get all registered buffers with their IDs
 * @param buffer_info Array to store buffer info with ID
 * @param max_buffers Maximum number of buffers to retrieve
 * @return Number of buffers retrieved
 */
typedef struct {
    int id;
    buffer_registration_t info;
} buffer_info_with_id_t;

int stats_get_all_buffers_with_id(buffer_info_with_id_t *buffer_info, int max_buffers);

/**
 * @brief Notify the stats module of a buffer swap
 * @param buffer_id Buffer registration ID
 * @return true on success, false on failure
 */
bool stats_buffer_swapped(int buffer_id);

/**
 * @brief Reset all statistics
 */
void stats_reset(void);

/**
 * @brief Reset task timing statistics
 * @param task_id Task ID (or -1 for all tasks)
 */
void stats_reset_task_timing(int task_id);

/**
 * @brief Get a string representation of optimization state
 * @param opt Optimization state
 * @return String description
 */
const char* stats_optimization_to_string(optimization_state_t opt);

/**
 * @brief Enable/disable automatic statistics collection
 * @param enabled true to enable, false to disable
 */
void stats_enable_collection(bool enabled);

#ifdef __cplusplus
}
#endif

#endif /* _STATS_H_ */
// File: ./Src/Core/Scheduler/fault_handlers.c
/**
* @file fault_handlers.c
* @brief Implementation of fault handlers for scheduler exceptions
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025-05-13
* 
* This file contains exception handlers for various fault conditions
* that may occur during task execution, including memory access violations,
* TrustZone security exceptions, and other system faults.
*/

#include "scheduler.h"
#include "scheduler_mpu_tz.h"
#include "scheduler_tz.h"
#include "stats.h"
#include "hardware/sync.h"
#include "hardware/sync/spin_lock.h"
#include "hardware/structs/sio.h"
#include "pico/platform.h"
#include <string.h>
#include <stdio.h>

/* Fault status register addresses */
#define SCB_CFSR        (*(volatile uint32_t *)(0xE000ED28))  /* Configurable Fault Status Register */
#define SCB_HFSR        (*(volatile uint32_t *)(0xE000ED2C))  /* HardFault Status Register */
#define SCB_DFSR        (*(volatile uint32_t *)(0xE000ED30))  /* Debug Fault Status Register */
#define SCB_MMFAR       (*(volatile uint32_t *)(0xE000ED34))  /* MemManage Fault Address Register */
#define SCB_BFAR        (*(volatile uint32_t *)(0xE000ED38))  /* BusFault Address Register */
#define SCB_AFSR        (*(volatile uint32_t *)(0xE000ED3C))  /* Auxiliary Fault Status Register */
#define NVIC_IABR0      (*(volatile uint32_t *)(0xE000E300))  /* Interrupt Active Bit Register */

/* CFSR bit definitions */
#define CFSR_IACCVIOL   (1UL << 0)  /* Instruction access violation */
#define CFSR_DACCVIOL   (1UL << 1)  /* Data access violation */
#define CFSR_MUNSTKERR  (1UL << 3)  /* Unstacking error */
#define CFSR_MSTKERR    (1UL << 4)  /* Stacking error */
#define CFSR_MLSPERR    (1UL << 5)  /* Floating-point lazy state preservation error */
#define CFSR_MMARVALID  (1UL << 7)  /* MMFAR holds a valid address */
#define CFSR_IBUSERR    (1UL << 8)  /* Instruction bus error */
#define CFSR_PRECISERR  (1UL << 9)  /* Precise data bus error */
#define CFSR_IMPRECISERR (1UL << 10) /* Imprecise data bus error */
#define CFSR_UNSTKERR   (1UL << 11) /* Unstacking error */
#define CFSR_STKERR     (1UL << 12) /* Stacking error */
#define CFSR_LSPERR     (1UL << 13) /* Floating-point lazy state preservation error */
#define CFSR_BFARVALID  (1UL << 15) /* BFAR holds a valid address */
#define CFSR_UNDEFINSTR (1UL << 16) /* Undefined instruction */
#define CFSR_INVSTATE   (1UL << 17) /* Invalid state */
#define CFSR_INVPC      (1UL << 18) /* Invalid PC load */
#define CFSR_NOCP       (1UL << 19) /* No coprocessor */
#define CFSR_UNALIGNED  (1UL << 24) /* Unaligned access */
#define CFSR_DIVBYZERO  (1UL << 25) /* Divide by zero */

/* HFSR bit definitions */
#define HFSR_VECTTBL    (1UL << 1)  /* Vector table read fault */
#define HFSR_FORCED     (1UL << 30) /* Forced hard fault */
#define HFSR_DEBUGEVT   (1UL << 31) /* Debug event hard fault */

/* Maximum number of tracked faults */
#define MAX_FAULT_RECORDS 16

/* Structure to store fault information for debugging */
typedef struct {
    uint32_t task_id;          /* ID of task that caused the fault */
    uint32_t fault_type;       /* Type of fault (from SCB_CFSR) */
    uint32_t fault_address;    /* Address that caused the fault */
    uint32_t lr;               /* Link register value */
    uint32_t pc;               /* Program counter */
    uint32_t psr;              /* Program Status Register */
    uint32_t fault_count;      /* Number of times this fault has occurred */
    absolute_time_t time;      /* Timestamp of the fault */
} fault_record_t;

/* Global fault record storage */
static fault_record_t fault_records[MAX_FAULT_RECORDS];
static uint8_t num_fault_records = 0;
static uint32_t total_fault_count = 0;

/* Spinlock for fault handler synchronization */
static spin_lock_t* fault_spinlock;
static uint32_t fault_spinlock_num;

/* Default task stack frame layout (ARM Cortex-M33) */
typedef struct {
    uint32_t r0;
    uint32_t r1;
    uint32_t r2;
    uint32_t r3;
    uint32_t r12;
    uint32_t lr;
    uint32_t pc;
    uint32_t psr;
} stack_frame_t;

/* Forward declaration of fault recovery function */
static bool attempt_fault_recovery(uint32_t fault_type, uint32_t fault_address, uint32_t task_id);

/* Initialize fault handlers */
void fault_handlers_init(void) {
    // Initialize spinlock for fault handler
    fault_spinlock_num = next_striped_spin_lock_num();
    fault_spinlock = spin_lock_init(fault_spinlock_num);
    
    // Clear fault records
    memset(fault_records, 0, sizeof(fault_records));
    num_fault_records = 0;
    total_fault_count = 0;
}

/**
 * @brief Record a fault for later analysis
 * 
 * @param task_id Task ID that caused the fault
 * @param fault_type Fault type from SCB_CFSR
 * @param fault_address Address that caused the fault
 * @param lr Link register value
 * @param pc Program counter value
 * @param psr Program Status Register value
 */
__attribute__((section(".time_critical")))
static void record_fault(uint32_t task_id, uint32_t fault_type, uint32_t fault_address,
    uint32_t lr, uint32_t pc, uint32_t psr) {

    uint32_t owner_irq = spin_lock_blocking(fault_spinlock);
    
    // Increment total fault count
    total_fault_count++;
    
    // Check if we already have a record for this fault
    bool found = false;
    for (int i = 0; i < num_fault_records; i++) {
        if (fault_records[i].task_id == task_id && 
            fault_records[i].fault_type == fault_type &&
            fault_records[i].fault_address == fault_address) {
            // Update existing record
            fault_records[i].fault_count++;
            fault_records[i].time = get_absolute_time();
            fault_records[i].lr = lr;
            fault_records[i].pc = pc;
            fault_records[i].psr = psr;
            found = true;
            break;
        }
    }
    
    // If not found and we have space, create a new record
    if (!found && num_fault_records < MAX_FAULT_RECORDS) {
        fault_record_t *record = &fault_records[num_fault_records++];
        record->task_id = task_id;
        record->fault_type = fault_type;
        record->fault_address = fault_address;
        record->lr = lr;
        record->pc = pc;
        record->psr = psr;
        record->fault_count = 1;
        record->time = get_absolute_time();
    }
    
    // Release spinlock
    spin_unlock(fault_spinlock, owner_irq);
}

/**
 * @brief Get fault records for diagnostic purposes
 * 
 * @param records Array to store fault records
 * @param max_records Maximum number of records to retrieve
 * @return Number of records retrieved
 */
__attribute__((section(".time_critical")))
uint8_t get_fault_records(fault_record_t *records, uint8_t max_records) {
    if (!records || max_records == 0) {
        return 0;
    }
    
    uint32_t owner_irq = spin_lock_blocking(fault_spinlock);
    
    // Copy records
    uint8_t count = num_fault_records;
    if (count > max_records) {
        count = max_records;
    }
    
    memcpy(records, fault_records, count * sizeof(fault_record_t));
    
    // Release spinlock
    spin_unlock(fault_spinlock, owner_irq);
    
    return count;
}

/**
 * @brief Get total fault count
 * 
 * @return Total number of faults encountered
 */
__attribute__((section(".time_critical")))
uint32_t get_total_fault_count(void) {
    return total_fault_count;
}

/**
 * @brief Clear fault records
 */
__attribute__((section(".time_critical")))
void clear_fault_records(void) {
    uint32_t owner_irq = spin_lock_blocking(fault_spinlock);
    
    // Clear records
    memset(fault_records, 0, sizeof(fault_records));
    num_fault_records = 0;
    
    // Release spinlock
    spin_unlock(fault_spinlock, owner_irq);
}

/**
 * @brief Attempt to recover from a fault
 * 
 * This function tries to recover from certain types of faults
 * to prevent system crashes. Recovery strategies include:
 * - Skipping the faulting instruction
 * - Terminating the offending task
 * - Adjusting MPU permissions
 * 
 * @param fault_type Fault type from SCB_CFSR
 * @param fault_address Address that caused the fault
 * @param task_id Task ID that caused the fault
 * @return true if recovery was successful, false otherwise
 */
__attribute__((section(".time_critical")))
static bool attempt_fault_recovery(uint32_t fault_type, uint32_t fault_address, uint32_t task_id) {
    bool recovery_successful = false;
    
    // Check if it's a memory access violation that we can recover from
    if (fault_type & (CFSR_DACCVIOL | CFSR_IACCVIOL)) {
        // Check if this is a memory boundary issue we can resolve
        // For example, we might relax MPU permissions for this task
        
        // First, try to terminate the offending task
        if (scheduler_delete_task(task_id)) {
            recovery_successful = true;
        }
    }
    
    // Check if it's an undefined instruction or invalid state
    else if (fault_type & (CFSR_UNDEFINSTR | CFSR_INVSTATE)) {
        // Not much we can do except terminate the task
        recovery_successful = scheduler_delete_task(task_id);
    }
    
    // Check if it's a divide-by-zero error
    else if (fault_type & CFSR_DIVBYZERO) {
        // We might be able to skip this instruction
        // In a real implementation, we would need to modify the
        // saved context to skip the faulting instruction
        
        // For now, just terminate the task
        recovery_successful = scheduler_delete_task(task_id);
    }
    
    return recovery_successful;
}

/**
 * @brief Common fault handler implementation
 * 
 * This function is called by all the specific fault handlers.
 * It analyzes the fault, records it, and attempts recovery if possible.
 * 
 * @param stack_frame Pointer to exception stack frame
 * @param is_hard_fault Whether this is a hard fault (vs. memmanage, busfault, etc.)
 * @return true if execution can continue, false if fatal
 */
__attribute__((section(".time_critical")))
static bool handle_fault(stack_frame_t *stack_frame, bool is_hard_fault) {
    uint32_t cfsr = SCB_CFSR;
    uint32_t hfsr = SCB_HFSR;
    uint32_t dfsr = SCB_DFSR;
    uint32_t fault_address = 0;
    uint32_t fault_type = cfsr;
    
    // Get current task ID
    uint32_t task_id = scheduler_get_current_task();
    
    // Determine fault address
    if (cfsr & CFSR_MMARVALID) {
        fault_address = SCB_MMFAR;
    } else if (cfsr & CFSR_BFARVALID) {
        fault_address = SCB_BFAR;
    } else {
        fault_address = stack_frame->pc;  // Use PC as a fallback
    }
    
    // Record the fault for later analysis
    record_fault(task_id, fault_type, fault_address, 
                stack_frame->lr, stack_frame->pc, stack_frame->psr);
    
    // Attempt recovery if possible
    bool recovery_successful = attempt_fault_recovery(fault_type, fault_address, task_id);
    
    // If recovery failed and this is a hard fault, we might need to reset
    if (!recovery_successful && is_hard_fault) {
        // In a real system, we might reset or enter a safe mode
        // For now, just try to terminate the task as a last resort
        recovery_successful = scheduler_delete_task(task_id);
    }
    
    // Clear fault status registers to prevent recurrence
    SCB_CFSR = SCB_CFSR;  // Write value back to clear
    SCB_HFSR = SCB_HFSR;
    SCB_DFSR = SCB_DFSR;
    
    return recovery_successful;
}

/**
 * @brief HardFault handler
 * 
 * This is called for serious system faults that cannot be handled
 * by other fault handlers.
 */
void __attribute__((naked)) HardFault_Handler(void) {
    __asm volatile (
        "tst lr, #4                        \n" // Test EXC_RETURN[2]
        "ite eq                            \n" // If zero (using MSP)...
        "mrseq r0, msp                     \n" // Use MSP as stack frame pointer
        "mrsne r0, psp                     \n" // Else use PSP
        "ldr r1, =handle_hard_fault        \n" // Load C handler address
        "bx r1                             \n" // Branch to C handler
    );
}

/**
 * @brief C handler for HardFault
 * 
 * Called by the assembly HardFault_Handler to process the fault
 * 
 * @param stack_frame Pointer to exception stack frame
 */
__attribute__((section(".time_critical")))
void handle_hard_fault(stack_frame_t *stack_frame) {
    bool can_continue = handle_fault(stack_frame, true);
    
    if (can_continue) {
        // We can return from the exception
        return;
    } else {
        // Fatal error, cannot continue - in a real system we would reset
        // or enter a safe state
        
        // For now, just enter an infinite loop
        while (1) {
            // Maybe blink an LED to indicate fatal error
            // In real implementation, we would log fault info
            // and perform system reset
        }
    }
}

/**
 * @brief MemManage fault handler
 * 
 * Called when a memory access violation occurs, typically due to
 * MPU region violations.
 */
void __attribute__((naked)) MemManage_Handler(void) {
    __asm volatile (
        "tst lr, #4                        \n" // Test EXC_RETURN[2]
        "ite eq                            \n" // If zero (using MSP)...
        "mrseq r0, msp                     \n" // Use MSP as stack frame pointer
        "mrsne r0, psp                     \n" // Else use PSP
        "ldr r1, =handle_memmanage_fault   \n" // Load C handler address
        "bx r1                             \n" // Branch to C handler
    );
}

/**
 * @brief C handler for MemManage fault
 * 
 * Called by the assembly MemManage_Handler to process the fault
 * 
 * @param stack_frame Pointer to exception stack frame
 */
__attribute__((section(".time_critical")))
void handle_memmanage_fault(stack_frame_t *stack_frame) {
    bool can_continue = handle_fault(stack_frame, false);
    
    if (can_continue) {
        // We can return from the exception
        return;
    } else {
        // Escalate to HardFault
        __asm volatile ("b HardFault_Handler");
    }
}

/**
 * @brief BusFault handler
 * 
 * Called when a bus error occurs, such as an invalid memory access
 * or alignment error.
 */
void __attribute__((naked)) BusFault_Handler(void) {
    __asm volatile (
        "tst lr, #4                        \n" // Test EXC_RETURN[2]
        "ite eq                            \n" // If zero (using MSP)...
        "mrseq r0, msp                     \n" // Use MSP as stack frame pointer
        "mrsne r0, psp                     \n" // Else use PSP
        "ldr r1, =handle_bus_fault         \n" // Load C handler address
        "bx r1                             \n" // Branch to C handler
    );
}

/**
 * @brief C handler for BusFault
 * 
 * Called by the assembly BusFault_Handler to process the fault
 * 
 * @param stack_frame Pointer to exception stack frame
 */
__attribute__((section(".time_critical")))
void handle_bus_fault(stack_frame_t *stack_frame) {
    bool can_continue = handle_fault(stack_frame, false);
    
    if (can_continue) {
        // We can return from the exception
        return;
    } else {
        // Escalate to HardFault
        __asm volatile ("b HardFault_Handler");
    }
}

/**
 * @brief UsageFault handler
 * 
 * Called for various program errors such as executing undefined
 * instructions, attempting unaligned access, or divide-by-zero.
 */
void __attribute__((naked)) UsageFault_Handler(void) {
    __asm volatile (
        "tst lr, #4                        \n" // Test EXC_RETURN[2]
        "ite eq                            \n" // If zero (using MSP)...
        "mrseq r0, msp                     \n" // Use MSP as stack frame pointer
        "mrsne r0, psp                     \n" // Else use PSP
        "ldr r1, =handle_usage_fault       \n" // Load C handler address
        "bx r1                             \n" // Branch to C handler
    );
}

/**
 * @brief C handler for UsageFault
 * 
 * Called by the assembly UsageFault_Handler to process the fault
 * 
 * @param stack_frame Pointer to exception stack frame
 */
__attribute__((section(".time_critical")))
void handle_usage_fault(stack_frame_t *stack_frame) {
    bool can_continue = handle_fault(stack_frame, false);
    
    if (can_continue) {
        // We can return from the exception
        return;
    } else {
        // Escalate to HardFault
        __asm volatile ("b HardFault_Handler");
    }
}

/**
 * @brief SecureFault handler (TrustZone-specific)
 * 
 * Called when a TrustZone security violation occurs.
 */
void __attribute__((naked)) SecureFault_Handler(void) {
    __asm volatile (
        "tst lr, #4                        \n" // Test EXC_RETURN[2]
        "ite eq                            \n" // If zero (using MSP)...
        "mrseq r0, msp                     \n" // Use MSP as stack frame pointer
        "mrsne r0, psp                     \n" // Else use PSP
        "ldr r1, =handle_secure_fault      \n" // Load C handler address
        "bx r1                             \n" // Branch to C handler
    );
}

/**
 * @brief C handler for SecureFault
 * 
 * Called by the assembly SecureFault_Handler to process the fault
 * 
 * @param stack_frame Pointer to exception stack frame
 */
__attribute__((section(".time_critical")))
void handle_secure_fault(stack_frame_t *stack_frame) {
    // For TrustZone security violations, we handle similarly to other faults
    bool can_continue = handle_fault(stack_frame, false);
    
    if (can_continue) {
        // We can return from the exception
        return;
    } else {
        // Escalate to HardFault
        __asm volatile ("b HardFault_Handler");
    }
}

/**
 * @brief Get fault description
 * 
 * Converts a fault type code into a human-readable description
 * 
 * @param fault_type Fault type from SCB_CFSR
 * @return String description of the fault
 */
__attribute__((section(".time_critical")))
const char* get_fault_description(uint32_t fault_type) {
    // Check for memory management faults
    if (fault_type & CFSR_IACCVIOL)
        return "Instruction access violation";
    if (fault_type & CFSR_DACCVIOL)
        return "Data access violation";
    if (fault_type & CFSR_MUNSTKERR)
        return "Memory unstacking error";
    if (fault_type & CFSR_MSTKERR)
        return "Memory stacking error";
    
    // Check for bus faults
    if (fault_type & CFSR_IBUSERR)
        return "Instruction bus error";
    if (fault_type & CFSR_PRECISERR)
        return "Precise data bus error";
    if (fault_type & CFSR_IMPRECISERR)
        return "Imprecise data bus error";
    if (fault_type & CFSR_UNSTKERR)
        return "Bus unstacking error";
    if (fault_type & CFSR_STKERR)
        return "Bus stacking error";
    
    // Check for usage faults
    if (fault_type & CFSR_UNDEFINSTR)
        return "Undefined instruction";
    if (fault_type & CFSR_INVSTATE)
        return "Invalid state";
    if (fault_type & CFSR_INVPC)
        return "Invalid PC load";
    if (fault_type & CFSR_NOCP)
        return "No coprocessor";
    if (fault_type & CFSR_UNALIGNED)
        return "Unaligned access";
    if (fault_type & CFSR_DIVBYZERO)
        return "Divide by zero";
    
    // Default
    return "Unknown fault";
}
// File: ./Src/Core/Scheduler/log_manager.c
/**
* @file log_manager.c
* @brief Implementation of the logging system
* @author Based on Robert Fudge's work
* @date 2025-05-14
*/

#include "log_manager.h"
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/sync.h"
#include "hardware/flash.h"
#include "pico/mutex.h"
#include "pico/multicore.h"
#include "hardware/watchdog.h"

// FAT filesystem support (if available)
#ifdef USE_FATFS
#include "ff.h"
#include "f_util.h"
#include "hw_config.h"
#endif

// Define ANSI color codes for console output
#define ANSI_COLOR_RESET   "\x1b[0m"
#define ANSI_COLOR_RED     "\x1b[31m"
#define ANSI_COLOR_GREEN   "\x1b[32m"
#define ANSI_COLOR_YELLOW  "\x1b[33m"
#define ANSI_COLOR_BLUE    "\x1b[34m"
#define ANSI_COLOR_MAGENTA "\x1b[35m"
#define ANSI_COLOR_CYAN    "\x1b[36m"

// Default values
#define DEFAULT_BUFFER_SIZE 4096
#define DEFAULT_MAX_MESSAGE_SIZE 256
#define DEFAULT_SDCARD_FILENAME "logs.txt"
#define DEFAULT_FLASH_OFFSET (1024 * 1024)  // 1MB offset
#define DEFAULT_FLASH_SIZE (256 * 1024)     // 256KB size

// Internal configuration and state
typedef struct {
    log_config_t config;
    uint8_t* buffer;
    uint32_t buffer_head;
    uint32_t buffer_tail;
    uint32_t buffer_count;
    uint32_t sequence_counter;
    uint8_t active_destinations;
    mutex_t log_mutex;
    log_level_t current_levels[3];  // Console, SD card, Flash
    char* temp_buffer;
    uint32_t flash_write_offset;
    bool initialized;
} log_state_t;

// Global logging state
static log_state_t log_state;

// Forward declarations for internal functions
static void log_write_console(const log_message_t* message, const char* formatted_message);
static void log_write_sdcard(const log_message_t* message, const char* formatted_message);
static void log_write_flash(const log_message_t* message, const char* formatted_message);
static const char* log_level_to_string(log_level_t level);
static const char* log_level_to_color(log_level_t level);

/**
 * @brief Initialize the logging system
 */
bool log_init(const log_config_t* config) {
    if (log_state.initialized) {
        return true;  // Already initialized
    }
    
    // Initialize mutex
    mutex_init(&log_state.log_mutex);
    
    // Copy configuration
    if (config != NULL) {
        memcpy(&log_state.config, config, sizeof(log_config_t));
    } else {
        // Use default configuration
        log_get_default_config(&log_state.config);
    }
    
    // Allocate message buffer
    log_state.buffer = malloc(log_state.config.buffer_size);
    if (log_state.buffer == NULL) {
        return false;
    }
    
    // Allocate temporary message buffer
    log_state.temp_buffer = malloc(log_state.config.max_message_size);
    if (log_state.temp_buffer == NULL) {
        free(log_state.buffer);
        return false;
    }
    
    // Initialize buffer pointers
    log_state.buffer_head = 0;
    log_state.buffer_tail = 0;
    log_state.buffer_count = 0;
    log_state.sequence_counter = 0;
    
    // Set default levels
    log_state.current_levels[0] = log_state.config.console_level;
    log_state.current_levels[1] = log_state.config.sdcard_level;
    log_state.current_levels[2] = log_state.config.flash_level;
    
    // Set active destinations
    log_state.active_destinations = LOG_DEST_CONSOLE;  // Start with console only
    
    // Initialize flash offset
    log_state.flash_write_offset = log_state.config.flash_offset;
    
    // Initialize SD card if available
#ifdef USE_FATFS
    // SD card initialization would go here
    // If successful, set LOG_DEST_SDCARD in active_destinations
#endif
    
    log_state.initialized = true;
    
    // Log initialization message
    LOG_INFO("LogMgr", "Logging system initialized");
    
    return true;
}

/**
 * @brief Get default logging configuration
 */
__attribute__((section(".time_critical")))
void log_get_default_config(log_config_t* config) {
    if (config == NULL) {
        return;
    }
    
    memset(config, 0, sizeof(log_config_t));
    
    config->console_level = LOG_LEVEL_INFO;
    config->sdcard_level = LOG_LEVEL_DEBUG;
    config->flash_level = LOG_LEVEL_ERROR;
    config->buffer_size = DEFAULT_BUFFER_SIZE;
    config->max_message_size = DEFAULT_MAX_MESSAGE_SIZE;
    config->sdcard_filename = DEFAULT_SDCARD_FILENAME;
    config->flash_offset = DEFAULT_FLASH_OFFSET;
    config->flash_size = DEFAULT_FLASH_SIZE;
    config->include_timestamp = true;
    config->include_level = true;
    config->include_core_id = true;
    config->color_output = true;
}

/**
 * @brief Set the global logging level
 */
__attribute__((section(".time_critical")))
void log_set_level(log_level_t level, log_destination_t destination) {
    mutex_enter_blocking(&log_state.log_mutex);
    
    if (destination & LOG_DEST_CONSOLE) {
        log_state.current_levels[0] = level;
    }
    
    if (destination & LOG_DEST_SDCARD) {
        log_state.current_levels[1] = level;
    }
    
    if (destination & LOG_DEST_FLASH) {
        log_state.current_levels[2] = level;
    }
    
    mutex_exit(&log_state.log_mutex);
}

/**
 * @brief Set log output destinations
 */
__attribute__((section(".time_critical")))
void log_set_destinations(uint8_t destinations) {
    mutex_enter_blocking(&log_state.log_mutex);
    log_state.active_destinations = destinations;
    mutex_exit(&log_state.log_mutex);
}

/**
 * @brief Add a log message to the buffer
 */
__attribute__((section(".time_critical")))
void log_message(log_level_t level, const char* module, const char* format, ...) {
    if (!log_state.initialized) {
        return;
    }
    
    // Check if this level would be logged anywhere
    if (level < log_state.current_levels[0] && 
        level < log_state.current_levels[1] && 
        level < log_state.current_levels[2]) {
        return;  // Nothing would log this, so skip
    }
    
    mutex_enter_blocking(&log_state.log_mutex);
    
    // Format the message
    va_list args;
    va_start(args, format);
    vsnprintf(log_state.temp_buffer, log_state.config.max_message_size, format, args);
    va_end(args);
    
    // Create log message
    log_message_t message;
    message.timestamp = get_absolute_time();
    message.level = level;
    message.core_id = get_core_num();
    message.module = module;
    message.message = log_state.temp_buffer;
    message.seq_num = log_state.sequence_counter++;
    
    // Format message for output
    char formatted_buffer[log_state.config.max_message_size];
    size_t offset = 0;
    
    // Add timestamp if enabled
    if (log_state.config.include_timestamp) {
        uint32_t ms = to_ms_since_boot(message.timestamp);
        offset += snprintf(formatted_buffer + offset, 
                          log_state.config.max_message_size - offset,
                          "[%5lu.%03lu] ", 
                          ms / 1000, ms % 1000);
    }
    
    // Add level if enabled
    if (log_state.config.include_level) {
        offset += snprintf(formatted_buffer + offset,
                          log_state.config.max_message_size - offset,
                          "[%s] ", 
                          log_level_to_string(message.level));
    }
    
    // Add core ID if enabled
    if (log_state.config.include_core_id) {
        offset += snprintf(formatted_buffer + offset,
                          log_state.config.max_message_size - offset,
                          "[C%d] ", 
                          message.core_id);
    }
    
    // Add module name
    offset += snprintf(formatted_buffer + offset,
                      log_state.config.max_message_size - offset,
                      "[%s] ", 
                      message.module);
    
    // Add message content
    snprintf(formatted_buffer + offset,
            log_state.config.max_message_size - offset,
            "%s", 
            message.message);
    
    // Write to console immediately (no buffering for console)
    if ((log_state.active_destinations & LOG_DEST_CONSOLE) && 
        level >= log_state.current_levels[0]) {
        log_write_console(&message, formatted_buffer);
    }
    
    // Queue for SD card and flash (these are buffered)
    if (((log_state.active_destinations & LOG_DEST_SDCARD) && 
         level >= log_state.current_levels[1]) ||
        ((log_state.active_destinations & LOG_DEST_FLASH) && 
         level >= log_state.current_levels[2])) {
        
        // Store in circular buffer
        // In a real implementation, you'd store the message and its metadata
        // For simplicity, we're just storing the formatted string
        
        // Check if buffer is full
        if (log_state.buffer_count >= log_state.config.buffer_size) {
            // Buffer full - either overwrite or drop
            // For now, we'll just drop
            mutex_exit(&log_state.log_mutex);
            return;
        }
        
        // Add to buffer
        size_t msg_len = strlen(formatted_buffer);
        if (msg_len > 0) {
            // Store message length first (to make it easier to extract)
            uint8_t len_bytes[4];
            len_bytes[0] = (msg_len >> 24) & 0xFF;
            len_bytes[1] = (msg_len >> 16) & 0xFF;
            len_bytes[2] = (msg_len >> 8) & 0xFF;
            len_bytes[3] = msg_len & 0xFF;
            
            // Store length
            for (int i = 0; i < 4; i++) {
                log_state.buffer[log_state.buffer_head] = len_bytes[i];
                log_state.buffer_head = (log_state.buffer_head + 1) % log_state.config.buffer_size;
                log_state.buffer_count++;
            }
            
            // Store message
            for (size_t i = 0; i < msg_len; i++) {
                log_state.buffer[log_state.buffer_head] = formatted_buffer[i];
                log_state.buffer_head = (log_state.buffer_head + 1) % log_state.config.buffer_size;
                log_state.buffer_count++;
            }
        }
    }
    
    mutex_exit(&log_state.log_mutex);
}

/**
 * @brief Process and output pending log messages
 */
__attribute__((section(".time_critical")))
void log_process(void) {
    if (!log_state.initialized) {
        return;
    }
    
    mutex_enter_blocking(&log_state.log_mutex);
    
    // Process up to 10 messages at a time to avoid blocking too long
    for (int i = 0; i < 10 && log_state.buffer_count > 4; i++) {
        // Extract message length
        uint32_t msg_len = 0;
        for (int j = 0; j < 4; j++) {
            msg_len = (msg_len << 8) | log_state.buffer[log_state.buffer_tail];
            log_state.buffer_tail = (log_state.buffer_tail + 1) % log_state.config.buffer_size;
            log_state.buffer_count--;
        }
        
        // Validate length
        if (msg_len == 0 || msg_len > log_state.config.max_message_size) {
            // Invalid length - something went wrong
            // Log an error and reset buffer
            printf("ERROR: Invalid log message length: %lu\n", msg_len);
            log_state.buffer_head = 0;
            log_state.buffer_tail = 0;
            log_state.buffer_count = 0;
            break;
        }
        
        // Extract message
        char msg_buffer[log_state.config.max_message_size];
        for (size_t j = 0; j < msg_len && j < log_state.config.max_message_size - 1; j++) {
            msg_buffer[j] = log_state.buffer[log_state.buffer_tail];
            log_state.buffer_tail = (log_state.buffer_tail + 1) % log_state.config.buffer_size;
            log_state.buffer_count--;
        }
        msg_buffer[msg_len] = '\0';
        
        // Create a dummy message for the writers
        log_message_t dummy_message;
        dummy_message.timestamp = get_absolute_time();
        dummy_message.level = LOG_LEVEL_INFO;  // Default
        dummy_message.core_id = get_core_num();
        dummy_message.module = "BUFFER";
        dummy_message.message = msg_buffer;
        
        // Write to SD card
        if (log_state.active_destinations & LOG_DEST_SDCARD) {
            log_write_sdcard(&dummy_message, msg_buffer);
        }
        
        // Write to flash
        if (log_state.active_destinations & LOG_DEST_FLASH) {
            log_write_flash(&dummy_message, msg_buffer);
        }
    }
    
    mutex_exit(&log_state.log_mutex);
}

/**
 * @brief Flush all pending log messages
 */
__attribute__((section(".time_critical")))
void log_flush(void) {
    if (!log_state.initialized) {
        return;
    }
    
    // Process all pending messages
    while (log_state.buffer_count > 0) {
        log_process();
    }
}

/**
 * @brief Write message to console
 */
__attribute__((section(".time_critical")))
static void log_write_console(const log_message_t* message, const char* formatted_message) {
    if (log_state.config.color_output) {
        printf("%s%s%s\n", 
               log_level_to_color(message->level), 
               formatted_message, 
               ANSI_COLOR_RESET);
    } else {
        printf("%s\n", formatted_message);
    }
}

/**
 * @brief Write message to SD card
 */
static void log_write_sdcard(const log_message_t* message, const char* formatted_message) {
#ifdef USE_FATFS
    // SD card write implementation would go here
    // For now, just a placeholder
    static bool sd_file_opened = false;
    static FIL file;
    
    if (!sd_file_opened) {
        if (f_open(&file, log_state.config.sdcard_filename, FA_WRITE | FA_OPEN_APPEND | FA_OPEN_ALWAYS) != FR_OK) {
            return;
        }
        sd_file_opened = true;
    }
    
    // Write message
    UINT bw;
    f_write(&file, formatted_message, strlen(formatted_message), &bw);
    f_write(&file, "\n", 1, &bw);
    
    // Sync to SD card periodically
    static uint32_t sync_counter = 0;
    if (++sync_counter % 10 == 0) {
        f_sync(&file);
    }
#endif
}

/**
 * @brief Write message to flash
 */
__attribute__((section(".time_critical")))
static void log_write_flash(const log_message_t* message, const char* formatted_message) {
    // Check if we have enough space in flash
    size_t msg_len = strlen(formatted_message) + 1;  // Include null terminator
    
    // Round up to nearest 4 bytes (flash program size)
    msg_len = (msg_len + 3) & ~3;
    
    // Check if we have enough space
    if (log_state.flash_write_offset + msg_len > log_state.config.flash_offset + log_state.config.flash_size) {
        // Not enough space - wrap around to beginning
        log_state.flash_write_offset = log_state.config.flash_offset;
        
        // Erase the flash sector
        uint32_t sector_offset = log_state.flash_write_offset & ~(FLASH_SECTOR_SIZE - 1);
        flash_range_erase(sector_offset, FLASH_SECTOR_SIZE);
    }
    
    // Check if we need to erase a sector
    uint32_t current_sector = log_state.flash_write_offset & ~(FLASH_SECTOR_SIZE - 1);
    uint32_t end_sector = (log_state.flash_write_offset + msg_len) & ~(FLASH_SECTOR_SIZE - 1);
    
    if (current_sector != end_sector) {
        // Message crosses sector boundary - erase the next sector
        flash_range_erase(end_sector, FLASH_SECTOR_SIZE);
    }
    
    // Prepare message buffer (must be aligned to 4 bytes for flash program)
    uint8_t flash_buffer[256];  // Max message size
    memset(flash_buffer, 0, sizeof(flash_buffer));
    memcpy(flash_buffer, formatted_message, strlen(formatted_message) + 1);
    
    // Program flash
    uint32_t offset = log_state.flash_write_offset - XIP_BASE;
    flash_range_program(offset, flash_buffer, msg_len);
    
    // Update offset
    log_state.flash_write_offset += msg_len;
}

/**
 * @brief Convert log level to string
 */
__attribute__((section(".time_critical")))
static const char* log_level_to_string(log_level_t level) {
    switch (level) {
        case LOG_LEVEL_TRACE: return "TRACE";
        case LOG_LEVEL_DEBUG: return "DEBUG";
        case LOG_LEVEL_INFO:  return "INFO ";
        case LOG_LEVEL_WARN:  return "WARN ";
        case LOG_LEVEL_ERROR: return "ERROR";
        case LOG_LEVEL_FATAL: return "FATAL";
        default:              return "UNKN ";
    }
}

/**
 * @brief Convert log level to ANSI color code
 */
__attribute__((section(".time_critical")))
static const char* log_level_to_color(log_level_t level) {
    switch (level) {
        case LOG_LEVEL_TRACE: return ANSI_COLOR_BLUE;
        case LOG_LEVEL_DEBUG: return ANSI_COLOR_CYAN;
        case LOG_LEVEL_INFO:  return ANSI_COLOR_GREEN;
        case LOG_LEVEL_WARN:  return ANSI_COLOR_YELLOW;
        case LOG_LEVEL_ERROR: return ANSI_COLOR_RED;
        case LOG_LEVEL_FATAL: return ANSI_COLOR_MAGENTA;
        default:              return ANSI_COLOR_RESET;
    }
}
// File: ./Src/Core/Scheduler/scheduler.c
/**
* @file scheduler_fixed.c
* @brief Fixed scheduler with proper task scheduling
*/

#include "scheduler.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "pico/time.h"
#include "hardware/timer.h"
#include "hardware/sync.h"
#include "pico/multicore.h"

//Scheduler configuration
#define SCHEDULER_TICK_MS         10     //10ms tick

/** Task list for each core */
static task_control_block_t tasks[2][MAX_TASKS];

/** Current running task on each core */
static task_control_block_t *current_task[2] = {NULL, NULL};

/** Next task ID counter */
static volatile uint32_t next_task_id = 1;

/** Core synchronization structure */
static core_sync_t core_sync;

/** Scheduler statistics */
static scheduler_stats_t stats;

/** Scheduler tracing enabled flag */
static volatile bool tracing_enabled = false;

/** Scheduler timer */
struct repeating_timer scheduler_timer;

//Forward declarations
static bool scheduler_timer_callback(struct repeating_timer *t);
static void run_task(task_control_block_t *task);

/**
 * @brief Test task function
 */
__attribute__((aligned(32)))
void test_task(void *params) {
    int task_num = (int)(intptr_t)params;
    static int iteration[10] = {0};  //Track iterations per task
    
    //Run for one iteration each time called
    printf("\n[Task %d] Running iteration %d on core %d\n", 
           task_num, iteration[task_num]++, get_core_num());
    
    //Simulate work
    sleep_ms(500);
    
    //Tasks complete after 5 iterations
    if (iteration[task_num] >= 5) {
        printf("[Task %d] Completed!\n", task_num);
        //Task will be marked as COMPLETED by the scheduler
    }
}

/**
 * @brief Get next ready task for a core
 * @note This function should be placed in RAM
 */
__attribute__((section(".time_critical")))
task_control_block_t* scheduler_get_next_task(uint8_t core) {
    static uint8_t last_scheduled_index[2] = {0, 0};
    task_control_block_t *next_task = NULL;
    int highest_priority = -1;
    
    //First pass: find the highest priority level with ready tasks
    for (int i = 0; i < MAX_TASKS; i++) {
        task_control_block_t *task = &tasks[core][i];
        
        if (task->state == TASK_STATE_READY &&
            task->priority > highest_priority &&
            (task->core_affinity == core || task->core_affinity == 0xFF)) {
            
            highest_priority = task->priority;
        }
    }
    
    //Second pass: round-robin within the highest priority level
    if (highest_priority >= 0) {
        int start_index = (last_scheduled_index[core] + 1) % MAX_TASKS;
        int i = start_index;
        
        do {
            task_control_block_t *task = &tasks[core][i];
            
            if (task->state == TASK_STATE_READY &&
                task->priority == highest_priority &&
                (task->core_affinity == core || task->core_affinity == 0xFF)) {
                
                next_task = task;
                last_scheduled_index[core] = i;
                break;
            }
            
            i = (i + 1) % MAX_TASKS;
        } while (i != start_index);
    }
    
    return next_task;
}

/**
 * @brief Run a task
 * @note This function should be placed in RAM
 */
__attribute__((section(".time_critical")))
static void run_task(task_control_block_t *task) {
    if (task && task->function) {
        task->state = TASK_STATE_RUNNING;
        task->run_count++;
        
        if (tracing_enabled) {
            printf("Running task %s on core %d\n", task->name, get_core_num());
        }
        
        task->function(task->params);
        
        //Task completed
        uint8_t core = get_core_num();
        task->state = TASK_STATE_COMPLETED;
        current_task[core] = NULL;
        
        if (tracing_enabled) {
            printf("Task %s completed\n", task->name);
        }
    }
}

/**
 * @brief Timer callback for scheduler tick
 * 
 * Called periodically to perform task scheduling decisions.
 * Handles context switching and task state updates.
 * 
 * @param t Pointer to repeating timer structure
 * @return true to continue timer, false to stop
 * @note This function should be placed in RAM
 */
__attribute__((section(".time_critical")))
static bool scheduler_timer_callback(struct repeating_timer *t) {
    static uint64_t tick_count = 0;
    (void)t;
    
    tick_count++;
    
    if (!core_sync.scheduler_running) {
        return true;
    }
    
    //Only show minimal debug output if tracing is enabled
    if (tracing_enabled && tick_count % 1000 == 0) {
        printf("[Scheduler] Active (tick %llu)\n", tick_count);
    }
    
    //Schedule tasks for both cores, schedules both cores in the same loop
    for (uint8_t core = 0; core < 2; core++) {
        // Force current running task to READY state to allow switching
        if (current_task[core] && current_task[core]->state == TASK_STATE_RUNNING) {
            // For persistent tasks, move back to READY periodically
            if (current_task[core]->type == TASK_TYPE_PERSISTENT) {
                current_task[core]->state = TASK_STATE_READY;
            }
        }
        
        // Now find the highest priority ready task
        task_control_block_t *next_task = scheduler_get_next_task(core);
        
        if (next_task && next_task != current_task[core]) {
            current_task[core] = next_task;
            stats.context_switches++;
            
            if (core == 0) {
                stats.core0_switches++;
            } else {
                stats.core1_switches++;
            }
            
            if (tracing_enabled) {
                printf("[Scheduler] Core %d: switching to %s\n", 
                       core, next_task->name);
            }
        }
    }
    
    return true;  //Keep timer running
}

/**
 * @brief Core 1 entry point
 */
__attribute__((section(".time_critical")))
void scheduler_core1_entry(void) {
    core_sync.core1_started = true;
    
    printf("Core 1 started\n");
    
    while (1) {
        if (core_sync.scheduler_running && current_task[1]) {
            if (current_task[1]->state == TASK_STATE_READY) {
                run_task(current_task[1]);
            }
        }
        
        tight_loop_contents();
    }
}

//Public API Implementation

__attribute__((aligned(32)))
bool scheduler_init(void) {
    printf("scheduler_init: Starting\n");
    
    //Initialize synchronization objects
    core_sync.task_list_lock_num = spin_lock_claim_unused(true);
    core_sync.scheduler_lock_num = spin_lock_claim_unused(true);
    core_sync.core1_started = false;
    core_sync.scheduler_running = false;
    
    //Clear task lists and stats
    memset(tasks, 0, sizeof(tasks));
    memset(&stats, 0, sizeof(stats));
    
    printf("scheduler_init: Complete\n");
    return true;
}

__attribute__((aligned(32)))
bool scheduler_start(void) {
    if (core_sync.scheduler_running) {
        return false;
    }
    
    printf("scheduler_start: Starting\n");
    
    //Start core 1
    multicore_launch_core1(scheduler_core1_entry);
    
    //Wait for core 1
    while (!core_sync.core1_started) {
        tight_loop_contents();
    }
    
    //Start scheduler timer
    if (!add_repeating_timer_ms(SCHEDULER_TICK_MS, scheduler_timer_callback, NULL, &scheduler_timer)) {
        printf("Failed to start scheduler timer\n");
        return false;
    }
    
    core_sync.scheduler_running = true;
    stats.total_runtime = time_us_64();
    
    printf("scheduler_start: Scheduler running\n");
    return true;
}

__attribute__((aligned(32)))
void scheduler_stop(void) {
    core_sync.scheduler_running = false;
    cancel_repeating_timer(&scheduler_timer);
    multicore_reset_core1();
    printf("Scheduler stopped\n");
}

/**
 * @note This function should be placed in RAM
**/
__attribute__((section(".time_critical")))
int scheduler_create_task(task_func_t function, void *params, uint32_t stack_size,
                         task_priority_t priority, const char *name, uint8_t core_affinity, task_type_t task_type) {
    if (!function || (core_affinity > 1 && core_affinity != 0xFF)) {
        return -1;
    }
    
    uint8_t target_core = (core_affinity == 0xFF) ? 0 : core_affinity;
    
    spin_lock_t *lock = spin_lock_instance(core_sync.task_list_lock_num);
    uint32_t save = spin_lock_blocking(lock);
    
    //Find empty slot
    int slot = -1;
    for (int i = 0; i < MAX_TASKS; i++) {
        if (tasks[target_core][i].state == TASK_STATE_INACTIVE) {
            slot = i;
            break;
        }
    }
    
    if (slot < 0) {
        spin_unlock(lock, save);
        return -1;
    }
    
    task_control_block_t *task = &tasks[target_core][slot];
    
    //Initialize task
    task->state = TASK_STATE_READY;
    task->priority = priority;
    task->function = function;
    task->params = params;
    task->core_affinity = core_affinity;
    task->type = task_type;
    task->task_id = next_task_id++;
    task->run_count = 0;
    strncpy(task->name, name, TASK_NAME_LEN - 1);
    task->name[TASK_NAME_LEN - 1] = '\0';
    
    stats.task_creates++;
    
    spin_unlock(lock, save);
    
    if (tracing_enabled) {
        printf("Created task %s (ID:%lu) on core %d\n", task->name, task->task_id, target_core);
    }
    
    return task->task_id;
}

/**
 * @note This function should be placed in RAM
**/
__attribute__((section(".time_critical")))
void scheduler_yield(void) {
    //Force a reschedule on next timer tick
    if (current_task[get_core_num()]) {
        current_task[get_core_num()]->state = TASK_STATE_READY;
    }
}

__attribute__((aligned(32)))
void scheduler_delay(uint32_t ms) {
    sleep_ms(ms);
}

/**
 * @note This function should be placed in RAM
**/
__attribute__((section(".time_critical")))
int scheduler_get_current_task(void) {
    uint8_t core = get_core_num();
    return current_task[core] ? current_task[core]->task_id : -1;
}

/**
 * @note This function should be placed in RAM
**/
__attribute__((section(".time_critical")))
bool scheduler_get_stats(scheduler_stats_t *stats_out) {
    if (!stats_out) return false;
    
    spin_lock_t *lock = spin_lock_instance(core_sync.scheduler_lock_num);
    uint32_t save = spin_lock_blocking(lock);
    
    memcpy(stats_out, &stats, sizeof(scheduler_stats_t));
    
    //Calculate runtime
    if (core_sync.scheduler_running) {
        stats_out->total_runtime = time_us_64() - stats.total_runtime;
    }
    
    spin_unlock(lock, save);
    return true;
}

/**
 * @note This function should be placed in RAM
**/
__attribute__((section(".time_critical")))
bool scheduler_get_task_info(int task_id, task_control_block_t *tcb) {
    if (!tcb || task_id < 0) return false;
    
    spin_lock_t *lock = spin_lock_instance(core_sync.task_list_lock_num);
    uint32_t save = spin_lock_blocking(lock);
    
    bool found = false;
    
    //Search both cores for the task
    for (int core = 0; core < 2 && !found; core++) {
        for (int i = 0; i < MAX_TASKS; i++) {
            if (tasks[core][i].task_id == (uint32_t)task_id && 
                tasks[core][i].state != TASK_STATE_INACTIVE) {
                memcpy(tcb, &tasks[core][i], sizeof(task_control_block_t));
                found = true;
                break;
            }
        }
    }
    
    spin_unlock(lock, save);
    return found;
}

/**
 * @note This function should be placed in RAM
**/
__attribute__((section(".time_critical")))
void scheduler_run_pending_tasks(void) {
    if (!core_sync.scheduler_running) {
        return;
    }
    
    // First find the current task for this core
    uint8_t core = get_core_num();
    task_control_block_t *task = current_task[core];
    
    // If there's no current task or it's not in READY state, find a new task
    if (!task || task->state != TASK_STATE_READY) {
        task = scheduler_get_next_task(core);
        current_task[core] = task;
    }
    
    // Run the task if we have one
    if (task && task->state == TASK_STATE_READY) {
        // Mark as running
        task->state = TASK_STATE_RUNNING;
        task->run_count++;
        
        // Run the task
        if (task->function) {
            task->function(task->params);
        }
        
        // Handle based on task type
        if (task->type == TASK_TYPE_PERSISTENT) {
            // Persistent tasks go back to READY
            task->state = TASK_STATE_READY;
        } else {
            // One-shot tasks complete
            task->state = TASK_STATE_COMPLETED;
            current_task[core] = NULL;
        }
    }
}

__attribute__((aligned(32)))
void scheduler_enable_tracing(bool enable) {
    tracing_enabled = enable;
    printf("Scheduler tracing %s\n", enable ? "enabled" : "disabled");
}

/**
 * @brief Get the current task for a specific core
 * 
 * @param core Core number (0 or 1)
 * @return Pointer to current task, or NULL if no task running
 */
task_control_block_t* scheduler_get_current_task_ptr(uint8_t core) {
    if (core < 2) {
        return current_task[core];
    }
    return NULL;
}

/**
 * @brief Set the current task for a specific core
 * 
 * @param core Core number (0 or 1)
 * @param task Pointer to task to set as current
 * @return true if successful, false otherwise
 */
bool scheduler_set_current_task_ptr(uint8_t core, task_control_block_t* task) {
    if (core < 2) {
        current_task[core] = task;
        return true;
    }
    return false;
}

//Stubs for unimplemented functions
__attribute__((aligned(32)))
bool scheduler_delete_task(int task_id) { (void)task_id; return false; }
__attribute__((aligned(32)))
bool scheduler_suspend_task(int task_id) { (void)task_id; return false; }
__attribute__((aligned(32)))
bool scheduler_resume_task(int task_id) { (void)task_id; return false; }
// File: ./Src/Core/Scheduler/scheduler_mpu_tz.c
/**
* @file scheduler_mpu_tz.c
* @brief Memory Protection Unit and TrustZone configuration for the scheduler
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025-05-13
*/

#include "scheduler_mpu_tz.h"
#include "scheduler.h"
#include "hardware/sync.h"
#include "hardware/structs/mpu.h"
#include "hardware/structs/sio.h"
#include "hardware/address_mapped.h"
#include "pico/platform.h"
#include <string.h>

/* Define maximum number of configurable regions per task */
#define MAX_MPU_REGIONS_PER_TASK 8

/* Define maximum number of tasks that can have MPU configurations */
#define MAX_MPU_TASKS 16

/* RP2350 has 8 MPU regions per core */
#define RP2350_MPU_REGIONS 8

/* ARM v8-M MPU register definitions */
#define MPU_TYPE        0xE000ED90  /* MPU Type Register */
#define MPU_CTRL        0xE000ED94  /* MPU Control Register */
#define MPU_RNR         0xE000ED98  /* MPU Region Number Register */
#define MPU_RBAR        0xE000ED9C  /* MPU Region Base Address Register */
#define MPU_RLAR        0xE000EDA0  /* MPU Region Limit Address Register */
#define MPU_RBAR_A1     0xE000EDA4  /* MPU alias registers */
#define MPU_RLAR_A1     0xE000EDA8
#define MPU_RBAR_A2     0xE000EDAC
#define MPU_RLAR_A2     0xE000EDB0
#define MPU_RBAR_A3     0xE000EDB4
#define MPU_RLAR_A3     0xE000EDB8

/* MPU Control Register bits */
#define MPU_CTRL_ENABLE          (1 << 0)
#define MPU_CTRL_HFNMIENA        (1 << 1)
#define MPU_CTRL_PRIVDEFENA      (1 << 2)

/* Region attribute bits for MPU_RLAR */
#define MPU_ATTR_XN              (1 << 0)    /* Execute Never */
#define MPU_ATTR_AP_RW_PRIV_ONLY (1 << 1)    /* RW by privileged code only */
#define MPU_ATTR_AP_RW_ANY       (3 << 1)    /* RW by any privilege level */
#define MPU_ATTR_AP_RO_PRIV_ONLY (5 << 1)    /* RO by privileged code only */
#define MPU_ATTR_AP_RO_ANY       (7 << 1)    /* RO by any privilege level */
#define MPU_ATTR_SH_NONE         (0 << 3)    /* Non-shareable */
#define MPU_ATTR_SH_OUTER        (2 << 3)    /* Outer shareable */
#define MPU_ATTR_SH_INNER        (3 << 3)    /* Inner shareable */
#define MPU_ATTR_ENABLE          (1 << 0)    /* Region enable bit */

/* Memory attributes for MPU region */
#define ATTR_DEVICE_nGnRnE       0x0         /* Device, non-Gathering, non-Reordering, no Early Write Acknowledgement */
#define ATTR_DEVICE_nGnRE        0x4         /* Device, non-Gathering, non-Reordering, Early Write Acknowledgement */
#define ATTR_NORMAL_WT_NT        0x5         /* Normal, Write-through, non-transient */
#define ATTR_NORMAL_WB_NT        0x7         /* Normal, Write-back, non-transient */
#define ATTR_NORMAL_NC           0x1         /* Normal, Non-cacheable */

/* Spin lock for MPU configuration synchronization between cores */
static spin_lock_t* mpu_spinlock;
static uint32_t mpu_spinlock_num;

/* Storage for task MPU configurations */
typedef struct {
    uint32_t task_id;
    bool configured;
    mpu_region_config_t regions[MAX_MPU_REGIONS_PER_TASK];
    uint8_t region_count;
} task_mpu_state_t;

static task_mpu_state_t task_mpu_states[MAX_MPU_TASKS];
static uint8_t num_configured_tasks = 0;

/* Private helper functions */

/**
 * @brief Get memory attribute encoding for the MPU
 */
__attribute__((section(".time_critical")))
static uint8_t get_memory_attr(bool cacheable, bool bufferable) {
    if (!cacheable && !bufferable) {
        return ATTR_NORMAL_NC;
    } else if (cacheable && !bufferable) {
        return ATTR_NORMAL_WT_NT;
    } else if (cacheable && bufferable) {
        return ATTR_NORMAL_WB_NT;
    } else {
        return ATTR_DEVICE_nGnRE;
    }
}

/**
 * @brief Get task MPU state by task ID
 */
__attribute__((section(".time_critical")))
static task_mpu_state_t* get_task_mpu_state(uint32_t task_id) {
    for (int i = 0; i < num_configured_tasks; i++) {
        if (task_mpu_states[i].task_id == task_id) {
            return &task_mpu_states[i];
        }
    }
    return NULL;
}

/**
 * @brief Calculate power of 2 size and alignment
 * 
 * MPU regions must be sized as powers of 2 and aligned to their size
 */
__attribute__((section(".time_critical")))
static void calculate_mpu_size(void *addr, size_t size, 
                            void **aligned_addr, size_t *aligned_size) {
    // Get closest power of 2 that is >= size
    size_t pow2_size = 32; // Minimum MPU region size is 32 bytes
    while (pow2_size < size) {
        pow2_size *= 2;
    }
    
    // Align address down to pow2_size boundary
    uintptr_t addr_val = (uintptr_t)addr;
    uintptr_t aligned = addr_val & ~(pow2_size - 1);
    
    // If original address was not aligned, we need a larger region
    if (aligned != addr_val) {
        pow2_size *= 2;
        aligned = addr_val & ~(pow2_size - 1);
    }
    
    *aligned_addr = (void *)aligned;
    *aligned_size = pow2_size;
}

/**
 * @brief Apply MPU region settings directly to hardware
 */
__attribute__((section(".time_critical")))
static void apply_mpu_region(int region_num, const mpu_region_config_t *config) {
    uint32_t rbar, rlar;
    uint32_t attr = 0;
    
    // Calculate aligned address and size (MPU requires power-of-2 alignment and size)
    void *aligned_addr;
    size_t aligned_size;
    calculate_mpu_size(config->start_addr, config->size, &aligned_addr, &aligned_size);
    
    // Base address must be aligned to region size
    rbar = (uint32_t)aligned_addr;
    
    // Configure attributes based on access permissions
    switch (config->access) {
        case MPU_NO_ACCESS:
            attr = 0; // No access for any privilege level
            break;
            
        case MPU_READ_ONLY:
            attr = MPU_ATTR_AP_RO_ANY | MPU_ATTR_XN;
            break;
            
        case MPU_READ_WRITE:
            attr = MPU_ATTR_AP_RW_ANY | MPU_ATTR_XN;
            break;
            
        case MPU_READ_EXEC:
            attr = MPU_ATTR_AP_RO_ANY;
            break;
            
        case MPU_READ_WRITE_EXEC:
            attr = MPU_ATTR_AP_RW_ANY;
            break;
    }
    
    // Configure shareability
    if (config->shareable) {
        attr |= MPU_ATTR_SH_INNER;
    } else {
        attr |= MPU_ATTR_SH_NONE;
    }
    
    // Configure memory type attributes
    uint8_t memattr = get_memory_attr(config->cacheable, config->bufferable);
    attr |= (memattr << 4);
    
    // Configure security attributes (TrustZone)
    if (config->security == TZ_NON_SECURE) {
        attr |= (1 << 5);
    } else if (config->security == TZ_NON_SECURE_CALLABLE) {
        attr |= (1 << 6);
    }
    
    // Set region limit address (note: RLAR contains limit address AND attributes)
    rlar = (uint32_t)aligned_addr + aligned_size - 1;
    rlar |= (attr << 8) | MPU_ATTR_ENABLE;
    
    // Write to MPU registers
    hw_write_masked(
        (io_rw_32*)(MPU_RNR),
        region_num,
        0xFF
    );
    hw_write_masked(
        (io_rw_32*)(MPU_RBAR),
        rbar,
        0xFFFFFFFF
    );
    hw_write_masked(
        (io_rw_32*)(MPU_RLAR),
        rlar,
        0xFFFFFFFF
    );
}

/**
 * @brief Disable an MPU region
 */
__attribute__((section(".time_critical")))
static void disable_mpu_region(int region_num) {
    // Select the region
    hw_write_masked(
        (io_rw_32*)(MPU_RNR),
        region_num,
        0xFF
    );
    
    // Clear the enable bit in RLAR
    hw_clear_bits((io_rw_32*)(MPU_RLAR), MPU_ATTR_ENABLE);
}

/* Public API implementation */

bool scheduler_mpu_tz_init(void) {
    // Initialize the spinlock for MPU configuration
    mpu_spinlock_num = next_striped_spin_lock_num();
    mpu_spinlock = spin_lock_init(mpu_spinlock_num);
    
    // Initialize MPU task state storage
    memset(task_mpu_states, 0, sizeof(task_mpu_states));
    num_configured_tasks = 0;
    
    // Enable MPU with default settings
    uint32_t ctrl = MPU_CTRL_ENABLE | MPU_CTRL_PRIVDEFENA;
    hw_write_masked(
        (io_rw_32*)(MPU_CTRL),
        ctrl,
        0x7 // Three lowest bits
    );
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_mpu_configure_task(const task_mpu_config_t *config) {
    if (!config || !config->regions || config->region_count == 0 || 
        config->region_count > MAX_MPU_REGIONS_PER_TASK) {
        return false;
    }
    
    // Acquire spinlock to prevent race conditions between cores
    uint32_t owner_irq = spin_lock_blocking(mpu_spinlock);
    
    // Check if task already has a configuration
    task_mpu_state_t *state = get_task_mpu_state(config->task_id);
    
    if (!state) {
        // No existing configuration, create new one if space available
        if (num_configured_tasks >= MAX_MPU_TASKS) {
            spin_unlock(mpu_spinlock, owner_irq);
            return false;
        }
        
        state = &task_mpu_states[num_configured_tasks++];
        state->task_id = config->task_id;
        state->configured = false;
        state->region_count = 0;
    }
    
    // Copy the configuration
    state->region_count = config->region_count;
    for (int i = 0; i < config->region_count; i++) {
        memcpy(&state->regions[i], &config->regions[i], sizeof(mpu_region_config_t));
    }
    
    state->configured = true;
    
    // Release spinlock
    spin_unlock(mpu_spinlock, owner_irq);
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_mpu_apply_task_settings(uint32_t task_id) {
    task_mpu_state_t *state;

    // Acquire spinlock
    uint32_t owner_irq = spin_lock_blocking(mpu_spinlock);
    
    // Find task configuration
    state = get_task_mpu_state(task_id);
    
    if (!state || !state->configured) {
        // No configuration found, use system defaults
        spin_unlock(mpu_spinlock, owner_irq);
        return false;
    }
    
    // First disable all MPU regions
    for (int i = 0; i < RP2350_MPU_REGIONS; i++) {
        disable_mpu_region(i);
    }
    
    // Apply task-specific regions
    int num_regions = state->region_count <= RP2350_MPU_REGIONS 
                     ? state->region_count : RP2350_MPU_REGIONS;
    
    for (int i = 0; i < num_regions; i++) {
        apply_mpu_region(i, &state->regions[i]);
    }
    
    // Release spinlock
    spin_unlock(mpu_spinlock, owner_irq);
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_mpu_reset_task_settings(uint32_t task_id) {
    uint32_t owner_irq = spin_lock_blocking(mpu_spinlock);
    
    // Disable all MPU regions
    for (int i = 0; i < RP2350_MPU_REGIONS; i++) {
        disable_mpu_region(i);
    }
    
    // Release spinlock
    spin_unlock(mpu_spinlock, owner_irq);
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_mpu_create_default_config(uint32_t task_id, 
    void *stack_start, size_t stack_size, void *code_start, size_t code_size,
    task_mpu_config_t *config) {

    static mpu_region_config_t regions[4];  // Stack, code, peripheral, shared
    
    if (!config || !stack_start || !code_start) {
        return false;
    }
    
    // Configure access to task's stack (RW, non-executable)
    regions[0].start_addr = stack_start;
    regions[0].size = stack_size;
    regions[0].access = MPU_READ_WRITE;
    regions[0].security = TZ_SECURE;
    regions[0].cacheable = true;
    regions[0].bufferable = true;
    regions[0].shareable = false;  // Stack is typically not shared between cores
    
    // Configure access to task's code (RX, not writable)
    regions[1].start_addr = code_start;
    regions[1].size = code_size;
    regions[1].access = MPU_READ_EXEC;
    regions[1].security = TZ_SECURE;
    regions[1].cacheable = true;
    regions[1].bufferable = false;  // Code shouldn't be buffered
    regions[1].shareable = true;    // Code can be shared between cores
    
    // Configure access to peripherals (device memory)
    regions[2].start_addr = (void *)0x40000000;  // Peripheral region in Cortex-M33
    regions[2].size = 0x20000000;               // 512MB peripheral space
    regions[2].access = MPU_READ_WRITE;
    regions[2].security = TZ_SECURE;
    regions[2].cacheable = false;
    regions[2].bufferable = false;
    regions[2].shareable = true;    // Peripherals are shared
    
    // Configure access to shared RAM region (if applicable)
    regions[3].start_addr = (void *)0x20000000;  // SRAM region
    regions[3].size = 0x100000;                 // 1MB (adjust as needed)
    regions[3].access = MPU_READ_WRITE;
    regions[3].security = TZ_SECURE;
    regions[3].cacheable = true;
    regions[3].bufferable = true;
    regions[3].shareable = true;    // Explicitly shared
    
    // Set up the configuration
    config->task_id = task_id;
    config->regions = regions;
    config->region_count = 4;
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_mpu_get_task_config(uint32_t task_id, task_mpu_config_t *config) {
    if (!config) {
        return false;
    }
    
    uint32_t owner_irq = spin_lock_blocking(mpu_spinlock);
    
    // Find task configuration
    task_mpu_state_t *state = get_task_mpu_state(task_id);
    
    if (!state || !state->configured) {
        spin_unlock(mpu_spinlock, owner_irq);
        return false;
    }
    
    // Copy configuration to output parameter
    config->task_id = task_id;
    config->region_count = state->region_count;
    config->regions = state->regions;
    
    // Release spinlock
    spin_unlock(mpu_spinlock, owner_irq);
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_mpu_is_accessible(void *addr, size_t size, bool write_access) {
    // This is a simplified implementation - a real one would need to check
    // against the actual MPU settings currently applied
    
    // For now, just check some basic ranges
    uintptr_t address = (uintptr_t)addr;
    
    // Check if address is in valid RAM range
    if (address >= 0x20000000 && address + size <= 0x20100000) {
        return true;
    }
    
    // Check if address is in valid flash range
    if (address >= 0x10000000 && address + size <= 0x11000000) {
        return true; // Allow read access to flash
    }
    
    // Check if address is in peripheral range and only allow if write_access is required
    if (address >= 0x40000000 && address + size <= 0x60000000) {
        return true; // Allow peripheral access
    }
    
    // Default: not accessible
    return false;
}
// File: ./Src/Core/Scheduler/scheduler_tz.c
/**
* @file scheduler_tz.c
* @brief TrustZone security configuration for the scheduler
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025-05-13
*/

#include "scheduler_tz.h"
#include "hardware/sync.h"
#include "hardware/structs/sio.h"
#include "pico/platform.h"
#include <string.h>

/* ARMv8-M TrustZone control registers */
#define TZ_SAU_CTRL       0xE000EDD0  /* SAU Control Register */
#define TZ_SAU_RNR        0xE000EDD8  /* SAU Region Number Register */
#define TZ_SAU_RBAR       0xE000EDDC  /* SAU Region Base Address Register */
#define TZ_SAU_RLAR       0xE000EDE0  /* SAU Region Limit Address Register */
#define TZ_NSACR          0xE000ED8C  /* Non-Secure Access Control Register */

/* SAU Control Register bits */
#define SAU_CTRL_ENABLE   (1 << 0)
#define SAU_CTRL_ALLNS    (1 << 1)

/* SAU Region Attribute bits */
#define SAU_REGION_ENABLE (1 << 0)
#define SAU_REGION_NSC    (1 << 1)  /* Non-Secure Callable */

/* Maximum number of secure functions */
#define MAX_SECURE_FUNCTIONS 32

/* Maximum number of tasks with TrustZone configurations */
#define MAX_TZ_TASKS 16

/* Spin lock for TrustZone configuration synchronization between cores */
static spin_lock_t* tz_spinlock;
static uint32_t tz_spinlock_num;

/* Flag indicating whether TrustZone is enabled */
static bool tz_enabled = false;

/* Storage for task TrustZone configurations */
typedef struct {
    uint32_t task_id;
    task_security_state_t security_state;
    secure_function_t secure_functions[MAX_SECURE_FUNCTIONS];
    uint8_t function_count;
    bool configured;
} task_tz_state_t;

static task_tz_state_t task_tz_states[MAX_TZ_TASKS];
static uint8_t num_configured_tz_tasks = 0;

/* Registry of secure functions */
static secure_function_t secure_function_registry[MAX_SECURE_FUNCTIONS];
static uint8_t num_registered_functions = 0;

/* Private helper functions */

/**
 * @brief Get task TrustZone state by task ID
 */
__attribute__((section(".time_critical")))
static task_tz_state_t* get_task_tz_state(uint32_t task_id) {
    for (int i = 0; i < num_configured_tz_tasks; i++) {
        if (task_tz_states[i].task_id == task_id) {
            return &task_tz_states[i];
        }
    }
    return NULL;
}

/**
 * @brief Check if we're currently running in secure state
 * 
 * @return true if in secure state, false if in non-secure state
 */
__attribute__((section(".time_critical")))
static bool is_secure_state(void) {
    // On ARMv8-M, we can check the AIRCR.BFHFNMINS bit
    // For the RP2350, we'll use a hardware-specific approach
    
    // This is a simplified implementation - in a real system,
    // you would use the proper hardware-specific registers
    
    // For the purposes of this implementation, assume we're 
    // always in secure state during initialization
    return true;
}

/**
 * @brief Configure SAU (Security Attribution Unit) regions
 * 
 * @param region_num Region number to configure
 * @param start_addr Start address of region
 * @param end_addr End address of region (inclusive)
 * @param nsc Whether region is Non-Secure Callable
 */
__attribute__((section(".time_critical")))
static void configure_sau_region(uint32_t region_num, 
                               void *start_addr, 
                               void *end_addr, 
                               bool nsc) {
    // Select the region
    hw_write_masked(
        (io_rw_32*)(TZ_SAU_RNR),
        region_num,
        0xFF
    );
    
    // Set base address
    hw_write_masked(
        (io_rw_32*)(TZ_SAU_RBAR),
        (uint32_t)start_addr,
        0xFFFFFFFF
    );
    
    // Set limit address and attributes
    uint32_t rlar = (uint32_t)end_addr;
    rlar |= SAU_REGION_ENABLE;
    if (nsc) {
        rlar |= SAU_REGION_NSC;
    }
    
    hw_write_masked(
        (io_rw_32*)(TZ_SAU_RLAR),
        rlar,
        0xFFFFFFFF
    );
}

/* Public API implementation */
__attribute__((section(".time_critical")))
bool scheduler_tz_init(void) {
    // Initialize the spinlock for TrustZone configuration
    tz_spinlock_num = next_striped_spin_lock_num();
    tz_spinlock = spin_lock_init(tz_spinlock_num);
    
    // Initialize TrustZone task state storage
    memset(task_tz_states, 0, sizeof(task_tz_states));
    num_configured_tz_tasks = 0;
    
    // Initialize secure function registry
    memset(secure_function_registry, 0, sizeof(secure_function_registry));
    num_registered_functions = 0;
    
    // Check if TrustZone extensions are present
    // This is a simplified check for RP2350
    uint32_t sau_type = *(io_ro_32*)(TZ_SAU_CTRL - 0x4);  // SAU_TYPE register
    if ((sau_type & 0xFF) == 0) {
        // No SAU regions available, TrustZone not supported
        tz_enabled = false;
        return false;
    }
    
    // Enable SAU
    hw_write_masked(
        (io_rw_32*)(TZ_SAU_CTRL),
        SAU_CTRL_ENABLE,
        SAU_CTRL_ENABLE
    );
    
    // Configure default SAU regions
    // Region 0: Mark SRAM as secure
    configure_sau_region(0, (void*)0x20000000, (void*)0x20040000, false);
    
    // Region 1: Mark Flash as secure
    configure_sau_region(1, (void*)0x10000000, (void*)0x10080000, false);
    
    // Region 2: Mark peripheral space as secure
    configure_sau_region(2, (void*)0x40000000, (void*)0x50000000, false);
    
    // Region 3: NSC veneer table area (to be populated at runtime)
    configure_sau_region(3, (void*)0x10080000, (void*)0x10081000, true);
    
    tz_enabled = true;
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_tz_configure_task(const task_tz_config_t *config) {
    if (!tz_enabled || !config) {
        return false;
    }
    

    // Acquire spinlock to prevent race conditions between cores
    uint32_t owner_irq = spin_lock_blocking(tz_spinlock);
    
    // Check if task already has a configuration
    task_tz_state_t *state = get_task_tz_state(config->task_id);
    
    if (!state) {
        // No existing configuration, create new one if space available
        if (num_configured_tz_tasks >= MAX_TZ_TASKS) {
            spin_unlock(tz_spinlock, owner_irq);
            return false;
        }
        
        state = &task_tz_states[num_configured_tz_tasks++];
        state->task_id = config->task_id;
        state->function_count = 0;
        state->configured = false;
    }
    
    // Copy the configuration
    state->security_state = config->security_state;
    
    // Copy secure function references (up to the maximum allowed)
    uint8_t function_count = config->function_count;
    if (function_count > MAX_SECURE_FUNCTIONS) {
        function_count = MAX_SECURE_FUNCTIONS;
    }
    
    state->function_count = function_count;
    for (int i = 0; i < function_count; i++) {
        memcpy(&state->secure_functions[i], &config->secure_functions[i], sizeof(secure_function_t));
    }
    
    state->configured = true;
    
    // Release spinlock
    spin_unlock(tz_spinlock, owner_irq);
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_tz_apply_task_settings(uint32_t task_id) {
    if (!tz_enabled) {
        return false;
    }
    
    task_tz_state_t *state;
    uint32_t owner_irq = spin_lock_blocking(tz_spinlock);
    
    // Find task configuration
    state = get_task_tz_state(task_id);
    
    if (!state || !state->configured) {
        // No configuration found, default to secure state
        spin_unlock(tz_spinlock, owner_irq);
        return true; // Not an error, just use defaults
    }
    
    // Apply security state transition if needed
    if (state->security_state == TASK_SECURITY_NON_SECURE) {
        // Set up transition to non-secure state
        // In a real implementation, this would involve setting up the
        // appropriate processor state and executing secure-to-non-secure transition
        
        // For RP2350, this would typically involve:
        // 1. Saving secure context
        // 2. Setting up NSACR (Non-Secure Access Control Register)
        // 3. Executing proper transition instruction
        
        // This is a placeholder - actual implementation would be hardware-specific
    }
    
    // Release spinlock
    spin_unlock(tz_spinlock, owner_irq);
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_tz_reset_task_settings(uint32_t task_id) {
    if (!tz_enabled) {
        return false;
    }
    
    uint32_t owner_irq = spin_lock_blocking(tz_spinlock);
    
    // Find task configuration
    task_tz_state_t *state = get_task_tz_state(task_id);
    
    if (state && state->configured) {
        // If task was in non-secure state, ensure we're back in secure state
        if (state->security_state == TASK_SECURITY_NON_SECURE) {
            // Return to secure state
            // In a real implementation, this would involve executing
            // a non-secure-to-secure transition sequence
            
            // This is a placeholder - actual implementation would be hardware-specific
        }
    }
    
    // Release spinlock
    spin_unlock(tz_spinlock, owner_irq);
    
    return true;
}

__attribute__((section(".time_critical")))
bool scheduler_tz_is_enabled(void) {
    return tz_enabled;
}

__attribute__((section(".time_critical")))
task_security_state_t scheduler_tz_get_security_state(void) {
    return is_secure_state() ? TASK_SECURITY_SECURE : TASK_SECURITY_NON_SECURE;
}

__attribute__((section(".time_critical")))
bool scheduler_tz_register_secure_function(const char *name, 
                                          void *secure_function,
                                          void **non_secure_callable) {
    if (!tz_enabled || !name || !secure_function || !non_secure_callable) {
        return false;
    }
    
    uint32_t owner_irq = spin_lock_blocking(tz_spinlock);
    
    bool success = false;
    
    // Check if we have space in the registry
    if (num_registered_functions < MAX_SECURE_FUNCTIONS) {
        // Add the function to the registry
        secure_function_t *reg = &secure_function_registry[num_registered_functions++];
        reg->name = name;
        reg->secure_gateway = secure_function;
        
        // Create NSC (Non-Secure Callable) veneer
        // In a real implementation, this would involve setting up a proper
        // veneer function in a non-secure callable memory region
        
        // For this implementation, we'll use a placeholder approach:
        // - Allocate a small block in the NSC region
        // - Create a veneer function that transitions to secure state,
        //   calls the secure function, and returns to non-secure state
        
        // This is just a placeholder - actual implementation would be hardware-specific
        void *veneer_addr = (void*)(0x10080000 + (num_registered_functions - 1) * 32);
        
        // Return the veneer address as the non-secure callable function
        *non_secure_callable = veneer_addr;
        reg->non_secure_callable = veneer_addr;
        
        success = true;
    }
    
    // Release spinlock
    spin_unlock(tz_spinlock, owner_irq);
    
    return success;
}
// File: ./Src/Core/Scheduler/sensor_manager_init.c
/**
* @file sensor_manager_init.c
* @brief Sensor manager initialization and task management implementation
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025-05-13
*/

#include "bmm350_adapter.h"
#include "sensor_manager.h"
#include "sensor_manager_init.h"
#include "scheduler.h"
#include "i2c_driver.h"
#include "hardware/sync.h"
#include "hardware/gpio.h"

#include <limits.h>
#include <stdlib.h>
#include <stdio.h>

// Global sensor manager instance (only accessible from this file)
static sensor_manager_t g_global_sensor_manager = NULL;

// Global I2C driver instance
static i2c_driver_ctx_t* g_i2c_driver = NULL;

// Sensor manager task ID from scheduler
static int g_sensor_task_id = -1;

// Spinlock for init/deinit operations
static spin_lock_t* g_init_lock;
static uint g_init_lock_num;

static void sensor_manager_scheduler_task(void *param);
static bool setup_default_sensors(sensor_manager_t manager);
static i2c_sensor_adapter_t setup_bmm350_sensor(sensor_manager_t manager);

/**
 * @brief Sensor manager task function for the scheduler
 * 
 * This function is registered with the scheduler and called periodically.
 * 
 * @param param Parameters (unused)
 */
__attribute__((section(".time_critical")))
static void sensor_manager_scheduler_task(void *param) {
    (void)param; // Unused parameter
    
    // Call the sensor manager task function
    sensor_manager_t manager = sensor_manager_get_instance();
    if (manager != NULL) {
        // Lock the manager during task execution - this is crucial
        // for preventing race conditions during sensor access
        if (sensor_manager_lock(manager)) {
            // Execute sensor manager task
            sensor_manager_task(manager);
            
            // Release the lock
            sensor_manager_unlock(manager);
        }
    }
}

bool sensor_manager_init(void) {
    // Initialize spinlock
    g_init_lock_num = spin_lock_claim_unused(true);
    if (g_init_lock_num == UINT_MAX) {
        printf("Failed to claim spinlock for sensor manager init\n");
        return false;
    }
    g_init_lock = spin_lock_instance(g_init_lock_num);
    
    // Acquire lock to prevent race conditions during initialization
    uint32_t save = spin_lock_blocking(g_init_lock);
    
    // Check if already initialized
    if (g_global_sensor_manager != NULL) {
        spin_unlock(g_init_lock, save);
        return true;  // Already initialized
    }
    
    // Initialize I2C driver
    i2c_driver_config_t i2c_config;
    i2c_driver_get_default_config(&i2c_config);
    
    // Use I2C0 on default pins (GPIO 16, 17)
    i2c_config.i2c_inst = i2c0;
    i2c_config.sda_pin = 16;
    i2c_config.scl_pin = 17;
    i2c_config.clock_freq = 400000;  // 400 kHz
    i2c_config.use_dma = true;       // Enable DMA for better performance
    
    g_i2c_driver = i2c_driver_init(&i2c_config);
    if (g_i2c_driver == NULL) {
        printf("Failed to initialize I2C driver\n");
        spin_unlock(g_init_lock, save);
        return false;
    }
    
    // Initialize sensor manager
    sensor_manager_config_t sm_config;
    sensor_manager_get_default_config(&sm_config);
    sm_config.i2c_ctx = g_i2c_driver;
    sm_config.task_period_ms = 10;  // 10ms (100Hz)
    
    g_global_sensor_manager = sensor_manager_create(&sm_config);
    if (g_global_sensor_manager == NULL) {
        printf("Failed to create sensor manager\n");
        i2c_driver_deinit(g_i2c_driver);
        g_i2c_driver = NULL;
        spin_unlock(g_init_lock, save);
        return false;
    }
    
    // Set up sensors (placeholder for your specific sensors)
    bool sensor_setup_success = setup_default_sensors(g_global_sensor_manager);
    if (!sensor_setup_success) {
        // Non-fatal warning
        printf("Warning: Some sensors failed to initialize\n");
    }
    
    // Create scheduler task
    // Use a dedicated task for sensor management with high priority
    // to ensure consistent sampling
    g_sensor_task_id = scheduler_create_task(
        sensor_manager_scheduler_task,    // Task function
        NULL,                             // No parameters needed
        2048,                             // Stack size (adjust as needed)
        TASK_PRIORITY_HIGH,               // High priority
        "sensor_mgr",                     // Task name
        1,                                // Core 0 for sensor tasks
        TASK_TYPE_PERSISTENT              // Runs indefinitely
    );
    
    if (g_sensor_task_id < 0) {
        printf("Failed to create sensor manager task\n");
        sensor_manager_destroy(g_global_sensor_manager);
        g_global_sensor_manager = NULL;
        i2c_driver_deinit(g_i2c_driver);
        g_i2c_driver = NULL;
        spin_unlock(g_init_lock, save);
        return false;
    }
    
    // Release lock
    spin_unlock(g_init_lock, save);
    
    printf("Sensor manager initialized successfully\n");
    return true;
}

/**
 * @brief Set up default sensors for the application
 * 
 * @param manager Sensor manager instance
 * @return true if at least one sensor was set up successfully
 */
static bool setup_default_sensors(sensor_manager_t manager) {
    if (manager == NULL) {
        return false;
    }
    
    bool any_success = false;
    
    // Set up BMM350 magnetometer
    i2c_sensor_adapter_t mag_adapter = setup_bmm350_sensor(manager);
    if (mag_adapter != NULL) {
        any_success = true;
    }
    
    // Add more sensors as needed
    
    return any_success;
}

/**
 * @brief Set up BMM350 magnetometer sensor
 * 
 * @param manager Sensor manager instance
 * @return Sensor adapter handle or NULL if failed
 */
static i2c_sensor_adapter_t setup_bmm350_sensor(sensor_manager_t manager) {
    // Create BMM350 adapter
    bmm350_task_tcb_t* bmm350_tcb = bmm350_adapter_init(g_i2c_driver);
    if (bmm350_tcb == NULL) {
        printf("Failed to initialize BMM350 adapter\n");
        return NULL;
    }
    
    // Create sensor adapter
    i2c_sensor_config_t config = {
        .type = SENSOR_TYPE_MAGNETOMETER,
        .mode = SENSOR_POWER_NORMAL,
        .rate = SENSOR_RATE_NORMAL,
        .int_enabled = true,
        .device_addr = BMM350_I2C_ADSEL_SET_LOW  // Default address
    };
    
    i2c_sensor_adapter_t adapter = i2c_sensor_adapter_create(
        g_i2c_driver,
        &config,
        bmm350_adapter_task,
        bmm350_tcb
    );
    
    if (adapter == NULL) {
        printf("Failed to create sensor adapter for BMM350\n");
        bmm350_adapter_deinit(bmm350_tcb);
        return NULL;
    }
    
    // Add to sensor manager
    if (!sensor_manager_add_sensor(manager, adapter)) {
        printf("Failed to add BMM350 sensor to manager\n");
        i2c_sensor_adapter_destroy(adapter);
        return NULL;
    }
    
    return adapter;
}

__attribute__((section(".time_critical")))
sensor_manager_t sensor_manager_get_instance(void) {
    return g_global_sensor_manager;
}

/**
 * @brief Deinitialize the sensor manager
 * 
 * @return true if deinitialized successfully
 */
bool sensor_manager_deinit(void) {
    // Acquire lock
    uint32_t save = spin_lock_blocking(g_init_lock);
    
    if (g_global_sensor_manager == NULL) {
        spin_unlock(g_init_lock, save);
        return true;  // Already deinitialized
    }
    
    // Remove scheduler task if it exists
    if (g_sensor_task_id >= 0) {
        scheduler_delete_task(g_sensor_task_id);
        g_sensor_task_id = -1;
    }
    
    // Destroy sensor manager
    sensor_manager_destroy(g_global_sensor_manager);
    g_global_sensor_manager = NULL;
    
    // Deinitialize I2C driver
    if (g_i2c_driver != NULL) {
        i2c_driver_deinit(g_i2c_driver);
        g_i2c_driver = NULL;
    }
    
    // Release lock
    spin_unlock(g_init_lock, save);
    
    return true;
}
// File: ./Src/Core/Scheduler/system_init.c
/**
* @file system_init.c
* @brief System initialization and startup sequence implementation
* @author Based on Robert Fudge's work
* @date 2025-05-14
*/

#include "system_init.h"
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "hardware/watchdog.h"
#include "hardware/sync.h"
#include "scheduler.h"
#include "log_manager.h"
#include "usb_shell.h"
#include "sensor_manager_init.h"
#include "scheduler_shell_commands.h"
#include "stats_shell_commands.h"
#include "hardware_stats_shell_commands.h"
#include "sensor_manager_shell_commands.h"

#include <string.h>
#include <stdio.h>

// Optional MPU/TZ includes
#ifdef ENABLE_MPU_TZ
#include "scheduler_mpu_tz.h"
#include "scheduler_tz.h"
#endif

// Module-level variables
static bool system_initialized = false;
static absolute_time_t system_start_time;
static sys_init_config_t system_config;
static bool watchdog_enabled = false;

// Forward declarations for internal functions
static sys_init_result_t init_hardware(void);
static sys_init_result_t init_scheduler(void);
static sys_init_result_t init_logging(void);
static sys_init_result_t init_shell(void);
static sys_init_result_t init_sensors(void);
static sys_init_result_t init_mpu_tz(void);
static void register_shell_commands(void);
static void print_banner(void);
static void shell_task_wrapper(void *params);
static sys_init_result_t init_shell_task(void);

// Add a global variable to track the shell task ID
static int shell_task_id = -1;

/**
 * @brief Print system information banner
 */
static void print_banner(void) {
    printf("\n");
    printf("=============================================\n");
    printf("  %s v%s\n", system_config.app_name, system_config.app_version);
    printf("  Board: Raspberry Pi Pico 2W (RP2350)\n");
    printf("  Build Date: %s %s\n", __DATE__, __TIME__);
    printf("=============================================\n");
    printf("\n");
}

/**
 * @brief Initialize system hardware components
 */
static sys_init_result_t init_hardware(void) {
    // Initialize standard I/O
    stdio_init_all();
    
    // Wait for USB to connect if using USB stdio
    #ifdef USE_WAIT_FOR_USB
    while (!stdio_usb_connected()) {
        sleep_ms(100);
    }
    #endif
    
    // Give time for USB to initialize
    sleep_ms(500);
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Hardware initialization complete\n");
    }
    
    return SYS_INIT_OK;
}

/**
 * @brief Initialize the scheduler
 */
static sys_init_result_t init_scheduler(void) {
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Initializing scheduler...\n");
    }
    
    if (!scheduler_init()) {
        printf("ERROR: Failed to initialize scheduler\n");
        return SYS_INIT_ERROR_SCHEDULER;
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Scheduler initialized successfully\n");
    }
    
    return SYS_INIT_OK;
}

/**
 * @brief Initialize the logging system
 */
static sys_init_result_t init_logging(void) {
    if (!(system_config.flags & SYS_INIT_FLAG_LOGGING)) {
        return SYS_INIT_OK; // Logging not requested
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Initializing logging system...\n");
    }
    
    // Configure logger
    log_config_t log_cfg;
    log_get_default_config(&log_cfg);
    
    // Define logging levels
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        log_cfg.console_level = LOG_LEVEL_DEBUG;
    } else {
        log_cfg.console_level = LOG_LEVEL_INFO;
    }
    
    log_cfg.flash_level = LOG_LEVEL_ERROR;
    log_cfg.buffer_size = 8192;
    
    // Initialize logger
    if (!log_init(&log_cfg)) {
        printf("ERROR: Failed to initialize logging system\n");
        return SYS_INIT_ERROR_LOGGER;
    }
    
    // Configure log destinations (start with console only)
    log_set_destinations(LOG_DEST_CONSOLE);
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Logging system initialized successfully\n");
    }
    
    // Log system initialization
    LOG_INFO("System", "Logging system initialized");
    
    return SYS_INIT_OK;
}

/**
 * @brief Initialize the shell
 */
/**
 * @brief Initialize the shell
 */
static sys_init_result_t init_shell(void) {
    if (!(system_config.flags & SYS_INIT_FLAG_SHELL)) {
        return SYS_INIT_OK; // Shell not requested
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Initializing shell...\n");
    }
    
    // Initialize shell
    shell_init();
    
    // Register shell commands
    register_shell_commands();
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Shell initialized successfully\n");
    }
    
    LOG_INFO("System", "Shell initialized");
    
    // Create the shell task
    sys_init_result_t result = init_shell_task();
    if (result != SYS_INIT_OK) {
        return result;
    }
    
    return SYS_INIT_OK;
}

/**
 * @brief Initialize sensors
 */
static sys_init_result_t init_sensors(void) {
    if (!(system_config.flags & SYS_INIT_FLAG_SENSORS)) {
        return SYS_INIT_OK; // Sensors not requested
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Initializing sensor manager...\n");
    }
    
    // Initialize sensor manager
    if (!sensor_manager_init()) {
        LOG_ERROR("System", "Failed to initialize sensor manager");
        return SYS_INIT_ERROR_SENSOR_MANAGER;
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Sensor manager initialized successfully\n");
    }
    
    LOG_INFO("System", "Sensor manager initialized");
    
    return SYS_INIT_OK;
}

/**
 * @brief Initialize MPU and TrustZone
 */
static sys_init_result_t init_mpu_tz(void) {
    if (!(system_config.flags & SYS_INIT_FLAG_MPU_TZ)) {
        return SYS_INIT_OK; // MPU/TZ not requested
    }
    
    #ifdef ENABLE_MPU_TZ
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Initializing MPU and TrustZone...\n");
    }
    
    // Initialize MPU
    if (!scheduler_mpu_tz_init()) {
        LOG_ERROR("System", "Failed to initialize MPU/TZ");
        return SYS_INIT_ERROR_MPU_TZ;
    }
    
    // Initialize TrustZone
    if (!scheduler_tz_init()) {
        LOG_ERROR("System", "Failed to initialize TrustZone");
        return SYS_INIT_ERROR_MPU_TZ;
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("MPU and TrustZone initialized successfully\n");
    }
    
    LOG_INFO("System", "MPU and TrustZone initialized");
    #else
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("MPU/TZ support not enabled in build\n");
    }
    
    LOG_WARN("System", "MPU/TZ requested but not enabled in build");
    #endif
    
    return SYS_INIT_OK;
}

/**
 * @brief Register shell commands
 */
static void register_shell_commands(void) {
    LOG_DEBUG("System", "Registering shell commands");
    
    // Register core commands
    register_scheduler_commands();
    register_stats_commands();
    register_cache_fpu_commands();
    
    // Register sensor commands if sensors enabled
    if (system_config.flags & SYS_INIT_FLAG_SENSORS) {
        register_sensor_manager_commands();
    }
    
    // Register application-specific commands
    system_register_commands();
    
    LOG_DEBUG("System", "Shell commands registered");
}

/**
 * @brief Initialize the system with custom configuration
 */
/**
 * @brief Initialize the system with custom configuration
 */
sys_init_result_t system_init(const sys_init_config_t* config) {
    sys_init_result_t result;
    
    // Store start time
    system_start_time = get_absolute_time();
    
    // Copy configuration
    if (config != NULL) {
        memcpy(&system_config, config, sizeof(sys_init_config_t));
    } else {
        // Use default configuration
        system_init_get_default_config(&system_config);
    }
    
    // First, initialize hardware
    result = init_hardware();
    if (result != SYS_INIT_OK) {
        return result;
    }
    
    // Print welcome banner
    print_banner();
    
    // Initialize scheduler (required)
    result = init_scheduler();
    if (result != SYS_INIT_OK) {
        return result;
    }
    
    // Initialize logging system (if requested)
    result = init_logging();
    if (result != SYS_INIT_OK) {
        return result;
    }
    
    // Initialize MPU and TrustZone (if requested)
    result = init_mpu_tz();
    if (result != SYS_INIT_OK) {
        return result;
    }
    
    // Initialize shell (if requested)
    result = init_shell();
    if (result != SYS_INIT_OK) {
        return result;
    }
    
    // Initialize sensors (if requested)
    result = init_sensors();
    if (result != SYS_INIT_OK) {
        return result;
    }
    
    // Start scheduler - MOVED BEFORE shell task creation
    LOG_INFO("System", "Starting scheduler");
    if (!scheduler_start()) {
        LOG_FATAL("System", "Failed to start scheduler");
        return SYS_INIT_ERROR_SCHEDULER;
    }
    
    
    
    // Setup watchdog if requested
    if (system_config.flags & SYS_INIT_FLAG_WATCHDOG) {
        uint32_t timeout_ms = system_config.watchdog_timeout_ms;
        if (timeout_ms < 100) timeout_ms = 100;  // Minimum 100ms
        
        LOG_INFO("System", "Enabling watchdog with %lu ms timeout", timeout_ms);
        watchdog_enable(timeout_ms, true);
        watchdog_enabled = true;
    }
    
    // Mark system as initialized
    system_initialized = true;
    
    LOG_INFO("System", "System initialization complete");
    
    return SYS_INIT_OK;
}

/**
 * @brief Get default system initialization configuration
 */
void system_init_get_default_config(sys_init_config_t* config) {
    if (config == NULL) {
        return;
    }
    
    memset(config, 0, sizeof(sys_init_config_t));
    
    config->flags = SYS_INIT_FLAG_DEFAULT;  // Shell, Sensors, Logging
    config->watchdog_timeout_ms = 5000;     // 5 second timeout
    config->app_name = "RobohandR1";
    config->app_version = "1.0.0";
}

/**
 * @brief Run the system main loop
 */
/**
 * @brief Run the system main loop
 */
void system_run(void) {
    if (!system_initialized) {
        printf("ERROR: System not initialized before system_run()\n");
        return;
    }
    
    LOG_INFO("System", "Entering main system loop");
    
    // Print initial prompt again to be sure
    printf("> ");
    
    // Main processing loop
    uint32_t loop_counter = 0;
    uint32_t last_stat_time = to_ms_since_boot(get_absolute_time());
    uint32_t last_shell_check = 0;
    
    while (1) {
        // Process log messages periodically
        if (system_config.flags & SYS_INIT_FLAG_LOGGING) {
            log_process();
        }
        
        // Run scheduler tasks
        scheduler_run_pending_tasks();
        
        // Feed watchdog if enabled
        if (watchdog_enabled && (loop_counter % 100 == 0)) {
            watchdog_update();
        }
        
        // Print statistics every 10 seconds in verbose mode
        uint32_t current_time = to_ms_since_boot(get_absolute_time());
        if ((system_config.flags & SYS_INIT_FLAG_VERBOSE) && 
            (current_time - last_stat_time > 30000)) {
            
            LOG_DEBUG("System", "System uptime: %lu ms", system_get_uptime_ms());
            last_stat_time = current_time;
        }
        
        // Brief delay to prevent CPU hogging
        sleep_ms(1); // Reduce to 1ms for better responsiveness
        
        loop_counter++;
    }
}

/**
 * @brief Register application commands with the shell
 * 
 * This is a weak function that can be overridden by the application
 */
__attribute__((weak)) void system_register_commands(void) {
    // Default implementation does nothing
    // Application should override this to register custom commands
}

/**
 * @brief Handle system shutdown
 */
void system_shutdown(bool restart) {
    LOG_INFO("System", "System shutdown initiated, restart=%d", restart);
    
    // Stop scheduler
    scheduler_stop();
    
    // Flush logs
    if (system_config.flags & SYS_INIT_FLAG_LOGGING) {
        log_flush();
    }
    
    // Give time for logs to flush
    sleep_ms(100);
    
    // If restarting, trigger watchdog reset
    if (restart) {
        LOG_INFO("System", "Restarting system...");
        sleep_ms(100);
        
        // Trigger reset
        watchdog_enable(1, false);  // 1ms timeout, no debug pause
        while (1) {
            // Wait for watchdog to reset system
        }
    }
    
    // Otherwise, just halt
    LOG_INFO("System", "System halted");
    while (1) {
        // Infinite loop
        __wfi();  // Wait for interrupt (low power)
    }
}

/**
 * @brief Get the time since system initialization
 */
uint32_t system_get_uptime_ms(void) {
    return to_ms_since_boot(get_absolute_time()) - 
           to_ms_since_boot(system_start_time);
}

/**
 * @brief Feed the watchdog to prevent system reset
 */
void system_feed_watchdog(void) {
    if (watchdog_enabled) {
        watchdog_update();
    }
}


/**
 * @brief Shell task wrapper function for the scheduler
 * 
 * This function is registered with the scheduler and processes shell input.
 * 
 * @param params Parameters (unused)
 */
static void shell_task_wrapper(void *params) {
    (void)params; // Unused parameter
    
    // Call the shell processing function
    shell_task();
    
    scheduler_yield();
}

/**
 * @brief Initialize the shell task
 * 
 * Creates a scheduler task for processing shell commands.
 * 
 * @return SYS_INIT_OK if successful, error code otherwise
 */
static sys_init_result_t init_shell_task(void) {
    if (!(system_config.flags & SYS_INIT_FLAG_SHELL)) {
        return SYS_INIT_OK; // Shell not requested
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Creating shell task...\n");
    }
    
    // Create a task for the shell
    shell_task_id = scheduler_create_task(
        shell_task_wrapper,        // Task function
        NULL,                      // No parameters needed
        1024,                      // Stack size (adjust as needed)
        TASK_PRIORITY_HIGH,      // Normal priority
        "shell",                   // Task name
        0,                         // Run on core 0
        TASK_TYPE_PERSISTENT       // Run continuously
    );
    
    if (shell_task_id < 0) {
        LOG_ERROR("System", "Failed to create shell task");
        return SYS_INIT_ERROR_SHELL;
    }
    
    if (system_config.flags & SYS_INIT_FLAG_VERBOSE) {
        printf("Shell task created with ID: %d\n", shell_task_id);
    }
    
    // Print initial prompt
    printf("> ");
    
    LOG_INFO("System", "Shell task initialized");
    
    return SYS_INIT_OK;
}
// File: ./Src/Core/Shell/hardware_stats_shell_commands.c
/**
* @file cache_fpu_shell_commands.c
* @brief Shell command interface for cache and FPU status
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025
* 
* This file implements shell commands for interacting with the
* cache and FPU stats functionality through a command-line interface.
*/

#include "hardware_stats_shell_commands.h"
#include "hardware_stats.h"
#include "pico/stdlib.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * @brief Print command usage information
 */
static void print_usage(void) {
    printf("Usage: cachefpu [command]\n");
    printf("Commands:\n");
    printf("  status       - Show basic cache and FPU status\n");
    printf("  detail       - Show detailed cache and processor information\n");
    printf("  benchmark    - Run FPU benchmark\n");
    printf("  monitor <n>  - Monitor cache and FPU status for n seconds\n");
    printf("If no command is given, 'status' is the default.\n");
}

/**
 * @brief Display basic cache and FPU status
 * 
 * @return 0 on success
 */
static int cmd_status(void) {
    cache_fpu_stats_t stats;
    cache_fpu_get_stats(&stats);
    
    printf("RP2350 Cache/FPU Status:\n");
    printf("------------------------\n");
    printf("FPU: %s\n", stats.fpu_enabled ? "Enabled" : "Disabled");
    printf("Instruction Cache: %s\n", stats.icache_enabled ? "Enabled" : "Disabled");
    printf("Data Cache: %s\n", stats.dcache_enabled ? "Enabled" : "Disabled");
    
    return 0;
}

/**
 * @brief Display detailed cache and processor information
 * 
 * @return 0 on success
 */
static int cmd_detail(void) {
    cache_fpu_stats_t stats;
    cache_fpu_get_stats(&stats);
    
    printf("RP2350 Detailed Cache/FPU Information:\n");
    printf("-------------------------------------\n");
    printf("FPU: %s\n", stats.fpu_enabled ? "Enabled" : "Disabled");
    printf("Instruction Cache: %s\n", stats.icache_enabled ? "Enabled" : "Disabled");
    printf("Data Cache: %s\n", stats.dcache_enabled ? "Enabled" : "Disabled");
    printf("Cache Levels: %lu\n", stats.cache_levels);
    printf("Instruction Cache Line Size: %lu bytes\n", stats.icache_line_size);
    printf("Data Cache Line Size: %lu bytes\n", stats.dcache_line_size);
    
    // Get processor details from compiler macros
    printf("\nProcessor Information:\n");
    printf("---------------------\n");
    printf("CPU: Cortex-M33\n");
    
    // Print compiler optimization level
    #if defined(__OPTIMIZE_SIZE__)
        printf("Optimization: -Os (size)\n");
    #elif defined(__OPTIMIZE__)
        #if defined(__OPTIMIZE_LEVEL__) && __OPTIMIZE_LEVEL__ == 3
            printf("Optimization: -O3 (speed)\n");
        #elif defined(__OPTIMIZE_LEVEL__) && __OPTIMIZE_LEVEL__ == 2
            printf("Optimization: -O2\n");
        #elif defined(__OPTIMIZE_LEVEL__) && __OPTIMIZE_LEVEL__ == 1
            printf("Optimization: -O1\n");
        #else
            printf("Optimization: Enabled\n");
        #endif
    #else
        printf("Optimization: None\n");
    #endif
    
    // Print FPU ABI
    #if defined(__ARM_FP) && defined(__ARM_PCS_VFP)
        printf("FPU ABI: hard\n");
    #elif defined(__ARM_FP)
        printf("FPU ABI: softfp\n");
    #else
        printf("FPU ABI: soft\n");
    #endif
    
    return 0;
}

/**
 * @brief Run FPU benchmark
 * 
 * @return 0 on success
 */
static int cmd_benchmark(void) {
    printf("Running FPU benchmark...\n");
    
    // Run the benchmark multiple times for better accuracy
    const int runs = 5;
    uint32_t times[runs];
    uint32_t total = 0;
    
    for (int i = 0; i < runs; i++) {
        times[i] = cache_fpu_benchmark_fpu();
        total += times[i];
        printf("Run %d: %lu us\n", i+1, times[i]);
    }
    
    printf("\nAverage execution time: %lu us\n", total / runs);
    
    // Check if FPU is enabled
    if (!cache_fpu_is_fpu_enabled()) {
        printf("\nWARNING: FPU is currently disabled!\n");
        printf("Performance may be significantly improved by enabling the FPU.\n");
    }
    
    return 0;
}

/**
 * @brief Monitor cache and FPU status for a period of time
 * 
 * @param seconds Duration to monitor in seconds
 * @return 0 on success, -1 on error
 */
static int cmd_monitor(int seconds) {
    if (seconds <= 0 || seconds > 60) {
        printf("Invalid duration. Please specify between 1 and 60 seconds.\n");
        return -1;
    }
    
    printf("Monitoring cache and FPU for %d seconds...\n", seconds);
    printf("Press any key to stop.\n\n");
    
    printf("Time(s)  FPU  I-Cache  D-Cache  Benchmark(us)\n");
    printf("-------  ---  -------  -------  ------------\n");
    
    // Clear any pending input
    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {
        // Discard any character
    }
    
    for (int i = 0; i < seconds; i++) {
        cache_fpu_stats_t stats;
        cache_fpu_get_stats(&stats);
        
        printf("%7d  %3s  %7s  %7s  %12lu\n", 
               i,
               stats.fpu_enabled ? "Yes" : "No",
               stats.icache_enabled ? "Yes" : "No",
               stats.dcache_enabled ? "Yes" : "No",
               stats.fpu_benchmark_time);
        
        // Check for key press to exit early
        for (int j = 0; j < 10; j++) {  // Split into smaller intervals for better responsiveness
            if (getchar_timeout_us(100000) != PICO_ERROR_TIMEOUT) {  // 100ms
                printf("\nMonitoring stopped by user.\n");
                return 0;
            }
        }
    }
    
    printf("\nMonitoring complete.\n");
    return 0;
}

/**
 * @brief Main command handler for cache/FPU shell commands
 * 
 * This function parses the command line arguments and calls the appropriate
 * command handler function.
 * 
 * @param argc Argument count
 * @param argv Argument vector
 * @return 0 on success, -1 on failure
 */
int cmd_cachefpu(int argc, char *argv[]) {
    // If no command given, show status
    if (argc < 2) {
        return cmd_status();
    }

    // Parse command
    if (strcmp(argv[1], "status") == 0) {
        return cmd_status();
    }
    else if (strcmp(argv[1], "detail") == 0) {
        return cmd_detail();
    }
    else if (strcmp(argv[1], "benchmark") == 0) {
        return cmd_benchmark();
    }
    else if (strcmp(argv[1], "monitor") == 0) {
        int seconds = 10;  // Default duration
        if (argc > 2) {
            seconds = atoi(argv[2]);
        }
        return cmd_monitor(seconds);
    }
    else if (strcmp(argv[1], "help") == 0) {
        print_usage();
        return 0;
    }
    else {
        printf("Unknown command: %s\n", argv[1]);
        print_usage();
        return -1;
    }
}

/**
 * @brief Register cache and FPU commands with the shell
 * 
 * This function registers the cache and FPU command handler with the shell system.
 * It should be called during system initialization.
 */
void register_cache_fpu_commands(void) {
    // Register the command with your shell system
    // Create a static shell_command_t struct first
    static const shell_command_t cachefpu_cmd = {
        "cachefpu",
        "Cache and FPU statistics and controls",
        cmd_cachefpu
    };
   
    // Then register it
    shell_register_command(&cachefpu_cmd);
}
// File: ./Src/Core/Shell/scheduler_shell_commands.c
/**
* @file scheduler_shell_commands_fixed.c
* @brief Fixed shell command implementations for scheduler control
*/

#include "scheduler_shell_commands.h"
#include "scheduler.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/time.h"

//External reference to test task
extern void test_task(void *params);

//Scheduler command definitions
static const shell_command_t scheduler_commands[] = {
    {"scheduler", "Control the scheduler (start|stop|status)", cmd_scheduler},
    {"task", "Create a test task (create <n> <priority> <core>)", cmd_task},
    {"ps", "List all tasks", cmd_ps},
    {"stats", "Show scheduler statistics", cmd_stats},
    {"trace", "Enable/disable scheduler tracing (on|off)", cmd_trace},
};

//Scheduler control command
int cmd_scheduler(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: scheduler <start|stop|status>\n\r");
        return 1;
    }
    
    if (strcmp(argv[1], "start") == 0) {
        printf("Starting scheduler...\n\r");
        if (scheduler_start()) {
            printf("Scheduler started successfully\n\r");
        } else {
            printf("Failed to start scheduler\n\r");
        }
    } 
    else if (strcmp(argv[1], "stop") == 0) {
        printf("Stopping scheduler...\n\r");
        scheduler_stop();
        printf("Scheduler stopped\n\r");
    } 
    else if (strcmp(argv[1], "status") == 0) {
        scheduler_stats_t stats;
        if (scheduler_get_stats(&stats)) {
            printf("Scheduler Status:\n\r");
            //Check if scheduler is actually running by looking at runtime
            bool running = (stats.total_runtime > 0) || (stats.context_switches > 0);
            printf("  Running: %s\n\r", running ? "Yes" : "No");
            printf("  Context switches: %lu\n\r", stats.context_switches);
            printf("  Tasks created: %lu\n\r", stats.task_creates);
            printf("  Core 0 switches: %lu\n\r", stats.core0_switches);
            printf("  Core 1 switches: %lu\n\r", stats.core1_switches);
            if (running) {
                printf("  Runtime: %llu us\n\r", stats.total_runtime);
            }
        } else {
            printf("Failed to get scheduler status\n\r");
        }
    } 
    else {
        printf("Unknown scheduler command: %s\n\r", argv[1]);
        return 1;
    }
    
    return 0;
}

//Task creation command
int cmd_task(int argc, char *argv[]) {
    if (argc < 5) {
        printf("Usage: task create <n> <priority> <core> [type]\n\r");
        printf("  n: task number\n\r");
        printf("  priority: 0-4 (idle-critical)\n\r");
        printf("  core: 0, 1, or -1 (any)\n\r");
        printf("  type: oneshot or persistent (default: oneshot)\n\r");
        return 1;
    }
    
    if (strcmp(argv[1], "create") != 0) {
        printf("Unknown task command: %s\n\r", argv[1]);
        return 1;
    }
    
    int task_num = atoi(argv[2]);
    int priority = atoi(argv[3]);
    int core = atoi(argv[4]);
    
    //Validate parameters
    if (priority < 0 || priority > 4) {
        printf("Invalid priority: %d (must be 0-4)\n\r", priority);
        return 1;
    }
    
    if (core < -1 || core > 1) {
        printf("Invalid core: %d (must be 0, 1, or -1)\n\r", core);
        return 1;
    }
    
    //Convert core value
    uint8_t core_affinity = (core == -1) ? 0xFF : (uint8_t)core;
    
    //Create task name
    char task_name[TASK_NAME_LEN];
    snprintf(task_name, sizeof(task_name), "test_%d", task_num);
    
    //Create the task
    task_type_t task_type = TASK_TYPE_ONESHOT;
    if (argc >= 6) {
        if (strcmp(argv[5], "persistent") == 0) {
            task_type = TASK_TYPE_PERSISTENT;
        }
    }
    
    //Create the task
    int task_id = scheduler_create_task(
        test_task,
        (void *)(intptr_t)task_num,
        0,
        (task_priority_t)priority,
        task_name,
        core_affinity,
        task_type
    );
    
    printf("Created %s task %s (ID: %d) with priority %d on core %s\n\r", task_type == TASK_TYPE_PERSISTENT ? "persistent" : "oneshot",
        task_name, task_id, priority, core == -1 ? "any" : (core == 0 ? "0" : "1"));

    return 0;
}

//List tasks command - fixed version
int cmd_ps(int argc, char *argv[]) {
    (void)argc;
    (void)argv;
    
    printf("Task List:\n\r");
    printf("ID  | Name           | State    | Priority | Core | Run Count\n\r");
    printf("----+----------------+----------+----------+------+----------\n\r");
    
    //Check all possible task IDs (a bit inefficient but works)
    for (int id = 1; id < 100; id++) {
        task_control_block_t tcb;
        if (scheduler_get_task_info(id, &tcb)) {
            const char *state_str;
            switch (tcb.state) {
                case TASK_STATE_INACTIVE:  state_str = "INACTIVE"; break;
                case TASK_STATE_READY:     state_str = "READY"; break;
                case TASK_STATE_RUNNING:   state_str = "RUNNING"; break;
                case TASK_STATE_BLOCKED:   state_str = "BLOCKED"; break;
                case TASK_STATE_SUSPENDED: state_str = "SUSPENDED"; break;
                case TASK_STATE_COMPLETED: state_str = "COMPLETED"; break;  //<-- Added
                default:                   state_str = "UNKNOWN"; break;
            }
            
            printf("%-3lu | %-14s | %-8s | %-8d | %-4s | %lu\n\r",
                   tcb.task_id,
                   tcb.name,
                   state_str,
                   tcb.priority,
                   tcb.core_affinity == 0xFF ? "any" : 
                       (tcb.core_affinity == 0 ? "0" : "1"),
                   tcb.run_count);
        }
    }
    
    return 0;
}

//Show statistics command
int cmd_stats(int argc, char *argv[]) {
    (void)argc;
    (void)argv;
    
    scheduler_stats_t stats;
    
    if (!scheduler_get_stats(&stats)) {
        printf("Failed to get scheduler statistics\n\r");
        return 1;
    }
    
    printf("Scheduler Statistics:\n\r");
    printf("  Total context switches: %lu\n\r", stats.context_switches);
    printf("  Core 0 switches: %lu\n\r", stats.core0_switches);
    printf("  Core 1 switches: %lu\n\r", stats.core1_switches);
    printf("  Tasks created: %lu\n\r", stats.task_creates);
    printf("  Tasks deleted: %lu\n\r", stats.task_deletes);
    printf("  Total runtime: %llu us\n\r", stats.total_runtime);
    
    return 0;
}

//Trace control command
int cmd_trace(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: trace <on|off>\n\r");
        return 1;
    }
    
    if (strcmp(argv[1], "on") == 0) {
        scheduler_enable_tracing(true);
    } else if (strcmp(argv[1], "off") == 0) {
        scheduler_enable_tracing(false);
    } else {
        printf("Invalid option: %s (use 'on' or 'off')\n\r", argv[1]);
        return 1;
    }
    
    return 0;
}

//Register scheduler commands with the shell
void register_scheduler_commands(void) {
    for (int i = 0; i < sizeof(scheduler_commands) / sizeof(scheduler_commands[0]); i++) {
        shell_register_command(&scheduler_commands[i]);
    }
}
// File: ./Src/Core/Shell/sensor_manager_shell_commands.c
/**
* @file sensor_manager_shell_commands.c
* @brief Shell command implementations for sensor manager
* @date 2025-05-13
*/

#include "sensor_manager_shell_commands.h"
#include "sensor_manager.h"
#include "sensor_manager_init.h"
#include "i2c_driver.h"
#include "scheduler.h"
#include "bmm350_adapter.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Shell command handler for sensor operations
int cmd_sensor(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: sensor <command> [args...]\n");
        printf("Commands:\n");
        printf("  info      - Show sensor info\n");
        printf("  start     - Start all sensors\n");
        printf("  stop      - Stop all sensors\n");
        printf("  start <type> - Start specific sensor\n");
        printf("  stop <type>  - Stop specific sensor\n");
        printf("  read <type>  - Read data from sensor\n");
        printf("  mode <type> <mode> - Set sensor power mode\n");
        printf("  rate <type> <rate> - Set sensor rate\n");
        printf("where <type> is: mag, accel, gyro, temp, press, hum\n");
        printf("and <mode> is: off, low, normal, high\n");
        printf("and <rate> is: off, low, normal, high, vhigh\n");
        return 1;
    }

    // Get the sensor manager instance through the accessor function
    sensor_manager_t manager = sensor_manager_get_instance();
    if (manager == NULL) {
        printf("Sensor manager not initialized\n");
        return 1;
    }

    // Parse sensor type if present
    sensor_type_t type = SENSOR_TYPE_UNKNOWN;
    if (argc > 2) {
        if (strcmp(argv[2], "mag") == 0) {
            type = SENSOR_TYPE_MAGNETOMETER;
        } else if (strcmp(argv[2], "accel") == 0) {
            type = SENSOR_TYPE_ACCELEROMETER;
        } else if (strcmp(argv[2], "gyro") == 0) {
            type = SENSOR_TYPE_GYROSCOPE;
        } else if (strcmp(argv[2], "temp") == 0) {
            type = SENSOR_TYPE_TEMPERATURE;
        } else if (strcmp(argv[2], "press") == 0) {
            type = SENSOR_TYPE_PRESSURE;
        } else if (strcmp(argv[2], "hum") == 0) {
            type = SENSOR_TYPE_HUMIDITY;
        }
    }

    // Process commands
    if (strcmp(argv[1], "info") == 0) {
        printf("Sensor Manager Status:\n");
        
        // Get scheduler task info to display task ID
        int task_id = -1;
        for (int i = 0; i < 100; i++) {  // Search for the sensor manager task
            task_control_block_t tcb;
            if (scheduler_get_task_info(i, &tcb)) {
                if (strcmp(tcb.name, "sensor_mgr") == 0) {
                    task_id = i;
                    break;
                }
            }
        }
        
        printf("Task ID: %d\n", task_id);
        
        // Check if sensors are available
        printf("Registered sensors:\n");
        sensor_type_t types[SENSOR_MANAGER_MAX_SENSORS];
        bool statuses[SENSOR_MANAGER_MAX_SENSORS];
        int count = sensor_manager_get_all_statuses(manager, types, statuses, SENSOR_MANAGER_MAX_SENSORS);
        
        if (count == 0) {
            printf("  No sensors found\n");
        } else {
            for (int i = 0; i < count; i++) {
                const char* type_name = "Unknown";
                
                // Convert type to string
                switch (types[i]) {
                    case SENSOR_TYPE_ACCELEROMETER: type_name = "Accelerometer"; break;
                    case SENSOR_TYPE_GYROSCOPE: type_name = "Gyroscope"; break;
                    case SENSOR_TYPE_MAGNETOMETER: type_name = "Magnetometer"; break;
                    case SENSOR_TYPE_PRESSURE: type_name = "Pressure"; break;
                    case SENSOR_TYPE_TEMPERATURE: type_name = "Temperature"; break;
                    case SENSOR_TYPE_HUMIDITY: type_name = "Humidity"; break;
                    case SENSOR_TYPE_LIGHT: type_name = "Light"; break;
                    case SENSOR_TYPE_PROXIMITY: type_name = "Proximity"; break;
                    case SENSOR_TYPE_IMU: type_name = "IMU"; break;
                    case SENSOR_TYPE_ENV: type_name = "Environmental"; break;
                    default: type_name = "Unknown"; break;
                }
                
                printf("  - %s: %s\n", type_name, statuses[i] ? "Running" : "Stopped");
            }
        }
        
    } else if (strcmp(argv[1], "start") == 0) {
        if (argc > 2) {
            // Start specific sensor
            if (type == SENSOR_TYPE_UNKNOWN) {
                printf("Unknown sensor type: %s\n", argv[2]);
                return 1;
            }
            
            if (sensor_manager_start_sensor(manager, type)) {
                printf("Started sensor: %s\n", argv[2]);
            } else {
                printf("Failed to start sensor: %s\n", argv[2]);
                return 1;
            }
        } else {
            // Start all sensors
            if (sensor_manager_start_all(manager)) {
                printf("Started all sensors\n");
            } else {
                printf("Failed to start all sensors\n");
                return 1;
            }
        }
        
    } else if (strcmp(argv[1], "stop") == 0) {
        if (argc > 2) {
            // Stop specific sensor
            if (type == SENSOR_TYPE_UNKNOWN) {
                printf("Unknown sensor type: %s\n", argv[2]);
                return 1;
            }
            
            if (sensor_manager_stop_sensor(manager, type)) {
                printf("Stopped sensor: %s\n", argv[2]);
            } else {
                printf("Failed to stop sensor: %s\n", argv[2]);
                return 1;
            }
        } else {
            // Stop all sensors
            if (sensor_manager_stop_all(manager)) {
                printf("Stopped all sensors\n");
            } else {
                printf("Failed to stop all sensors\n");
                return 1;
            }
        }
        
    } else if (strcmp(argv[1], "read") == 0) {
        if (argc < 3) {
            printf("Specify sensor type to read\n");
            return 1;
        }
        
        if (type == SENSOR_TYPE_UNKNOWN) {
            printf("Unknown sensor type: %s\n", argv[2]);
            return 1;
        }
        
        sensor_data_t data;
        if (sensor_manager_get_data(manager, type, &data)) {
            // Data will be printed by the callback, but we can also print it here
            switch(type) {
                case SENSOR_TYPE_MAGNETOMETER:
                    printf("MAG: X: %.2f, Y: %.2f, Z: %.2f\n", 
                        data.xyz.x, data.xyz.y, data.xyz.z);
                    break;
                
                case SENSOR_TYPE_ACCELEROMETER:
                    printf("ACCEL: X: %.2f, Y: %.2f, Z: %.2f\n", 
                        data.xyz.x, data.xyz.y, data.xyz.z);
                    break;
                    
                case SENSOR_TYPE_GYROSCOPE:
                    printf("GYRO: X: %.2f, Y: %.2f, Z: %.2f\n", 
                        data.xyz.x, data.xyz.y, data.xyz.z);
                    break;
                    
                case SENSOR_TYPE_TEMPERATURE:
                    printf("TEMP: %.2f °C\n", data.scalar.value);
                    break;
                    
                case SENSOR_TYPE_PRESSURE:
                    printf("PRESS: %.2f hPa\n", data.scalar.value);
                    break;
                    
                case SENSOR_TYPE_HUMIDITY:
                    printf("HUM: %.2f %%\n", data.scalar.value);
                    break;
                    
                default:
                    break;
            }
        } else {
            printf("No data available from sensor: %s\n", argv[2]);
            return 1;
        }
        
    } else if (strcmp(argv[1], "mode") == 0) {
        if (argc < 4) {
            printf("Specify sensor type and mode\n");
            return 1;
        }
        
        if (type == SENSOR_TYPE_UNKNOWN) {
            printf("Unknown sensor type: %s\n", argv[2]);
            return 1;
        }
        
        sensor_power_mode_t mode = SENSOR_POWER_NORMAL;
        if (strcmp(argv[3], "off") == 0) {
            mode = SENSOR_POWER_OFF;
        } else if (strcmp(argv[3], "low") == 0) {
            mode = SENSOR_POWER_LOW;
        } else if (strcmp(argv[3], "normal") == 0) {
            mode = SENSOR_POWER_NORMAL;
        } else if (strcmp(argv[3], "high") == 0) {
            mode = SENSOR_POWER_HIGH;
        } else {
            printf("Unknown power mode: %s\n", argv[3]);
            return 1;
        }
        
        if (sensor_manager_set_power_mode(manager, type, mode)) {
            printf("Set power mode for %s to %s\n", argv[2], argv[3]);
        } else {
            printf("Failed to set power mode\n");
            return 1;
        }
        
    } else if (strcmp(argv[1], "rate") == 0) {
        if (argc < 4) {
            printf("Specify sensor type and rate\n");
            return 1;
        }
        
        if (type == SENSOR_TYPE_UNKNOWN) {
            printf("Unknown sensor type: %s\n", argv[2]);
            return 1;
        }
        
        sensor_rate_t rate = SENSOR_RATE_NORMAL;
        if (strcmp(argv[3], "off") == 0) {
            rate = SENSOR_RATE_OFF;
        } else if (strcmp(argv[3], "low") == 0) {
            rate = SENSOR_RATE_LOW;
        } else if (strcmp(argv[3], "normal") == 0) {
            rate = SENSOR_RATE_NORMAL;
        } else if (strcmp(argv[3], "high") == 0) {
            rate = SENSOR_RATE_HIGH;
        } else if (strcmp(argv[3], "vhigh") == 0) {
            rate = SENSOR_RATE_VERY_HIGH;
        } else {
            printf("Unknown rate: %s\n", argv[3]);
            return 1;
        }
        
        if (sensor_manager_set_rate(manager, type, rate)) {
            printf("Set rate for %s to %s\n", argv[2], argv[3]);
        } else {
            printf("Failed to set rate\n");
            return 1;
        }
        
    } else if (strcmp(argv[1], "status") == 0) {
        sensor_type_t types[SENSOR_MANAGER_MAX_SENSORS];
        bool statuses[SENSOR_MANAGER_MAX_SENSORS];
        
        int count = sensor_manager_get_all_statuses(manager, types, statuses, SENSOR_MANAGER_MAX_SENSORS);
        
        if (count == 0) {
            printf("No sensors found\n");
        } else {
            printf("Sensor Status:\n");
            for (int i = 0; i < count; i++) {
                const char* type_name = "Unknown";
                
                // Convert type to string
                switch (types[i]) {
                    case SENSOR_TYPE_ACCELEROMETER: type_name = "Accelerometer"; break;
                    case SENSOR_TYPE_GYROSCOPE: type_name = "Gyroscope"; break;
                    case SENSOR_TYPE_MAGNETOMETER: type_name = "Magnetometer"; break;
                    case SENSOR_TYPE_PRESSURE: type_name = "Pressure"; break;
                    case SENSOR_TYPE_TEMPERATURE: type_name = "Temperature"; break;
                    case SENSOR_TYPE_HUMIDITY: type_name = "Humidity"; break;
                    case SENSOR_TYPE_LIGHT: type_name = "Light"; break;
                    case SENSOR_TYPE_PROXIMITY: type_name = "Proximity"; break;
                    case SENSOR_TYPE_IMU: type_name = "IMU"; break;
                    case SENSOR_TYPE_ENV: type_name = "Environmental"; break;
                    default: type_name = "Unknown"; break;
                }
                
                printf("  %s: %s\n", type_name, statuses[i] ? "RUNNING" : "STOPPED");
            }
        }
        
        return 0;
        
    } else {
        printf("Unknown command: %s\n", argv[1]);
        return 1;
    }

    return 0;
}

// Register sensor commands with the shell
void register_sensor_manager_commands(void) {
    static const shell_command_t sensor_command = {
        "sensor",
        "Sensor management commands",
        cmd_sensor
    };
    
    shell_register_command(&sensor_command);
}
// File: ./Src/Core/Shell/stats_shell_commands.c
/**
* @file stats_shell_commands.c
* @brief Shell command implementations for statistics module
*/

#include "stats_shell_commands.h"
#include "stats.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Stats command definitions
static const shell_command_t stats_commands[] = {
    {"sysstats", "Show system statistics", cmd_system_stats},
    {"taskstats", "Show task timing statistics", cmd_task_stats},
    {"opt", "Show/manage optimizations", cmd_optimizations},
    {"buffers", "Show registered buffers", cmd_buffers},
    {"statreset", "Reset statistics", cmd_stats_reset},
};

int cmd_system_stats(int argc, char *argv[]) {
    (void)argc;
    (void)argv;
    
    system_stats_t stats;
    if (!stats_get_system(&stats)) {
        printf("Failed to get system statistics\n\r");
        return 1;
    }
    
    printf("System Statistics:\n\r");
    printf("------------------\n\r");
    printf("System Frequency: %lu Hz\n\r", stats.system_freq_hz);
    printf("Voltage: %lu mV\n\r", stats.voltage_mv);
    printf("Current: %lu mA\n\r", stats.current_ma);
    printf("Temperature: %lu C\n\r", stats.temperature_c);
    printf("Uptime: %llu us\n\r", stats.uptime_us);
    printf("CPU Usage: %u%%\n\r", stats.cpu_usage_percent);
    printf("Core 0 Usage: %u%%\n\r", stats.core0_usage_percent);  
    printf("Core 1 Usage: %u%%\n\r", stats.core1_usage_percent);
    
    return 0;
}

int cmd_task_stats(int argc, char *argv[]) {
    task_timing_stats_t stats[MAX_TASK_STATS];
    int count = stats_get_all_task_timing(stats, MAX_TASK_STATS);
    
    if (argc > 1 && strcmp(argv[1], "reset") == 0) {
        int task_id = -1;
        if (argc > 2) {
            task_id = atoi(argv[2]);
        }
        stats_reset_task_timing(task_id);
        printf("Task timing statistics reset\n\r");
        return 0;
    }
    
    printf("Task Timing Statistics:\n\r");
    printf("----------------------\n\r");
    printf("ID  | Name           | Desired(us) | Actual(us) | Jitter(%) | Misses | Execs\n\r");
    printf("----+----------------+-------------+------------+-----------+--------+------\n\r");
    
    for (int i = 0; i < count; i++) {
        printf("%-3lu | %-14s | %-11lu | %-10lu | %-9.1f | %-6lu | %lu\n\r",
               stats[i].task_id,
               stats[i].task_name,
               stats[i].desired_period_us,
               stats[i].actual_period_us,
               stats[i].jitter_percent,
               stats[i].deadline_misses,
               stats[i].total_executions);
    }
    
    if (count == 0) {
        printf("No task timing data available\n\r");
    }
    
    return 0;
}

int cmd_optimizations(int argc, char *argv[]) {
    if (argc > 1 && strcmp(argv[1], "suggest") == 0) {
        optimization_suggestion_t suggestions[10];
        int count = stats_get_optimization_suggestions(suggestions, 10);
        
        printf("Optimization Suggestions:\n\r");
        printf("------------------------\n\r");
        
        if (count == 0) {
            printf("No optimization suggestions at this time\n\r");
        }
        
        for (int i = 0; i < count; i++) {
            printf("%d. %s\n\r", i+1, suggestions[i].description);
            printf("   Priority: %u/10\n\r", suggestions[i].priority);
            printf("   Expected Improvement: %.1f%%\n\r", suggestions[i].expected_improvement_percent);
            printf("\n\r");
        }
       
       return 0;
    }
   
    optimization_state_t opts = stats_get_optimizations();
   
    printf("Active Optimizations:\n\r");
    printf("--------------------\n\r");
   
    for (int i = 0; i < 8; i++) {
        optimization_state_t opt = 1 << i;
        bool active = (opts & opt) != 0;
        printf("%s: %s\n\r", stats_optimization_to_string(opt), active ? "Enabled" : "Disabled");
    }
   
    return 0;
}

int cmd_buffers(int argc, char *argv[]) {
    (void)argc;
    (void)argv;
    
    buffer_info_with_id_t buffer_info[MAX_REGISTERED_BUFFERS];
    int count = stats_get_all_buffers_with_id(buffer_info, MAX_REGISTERED_BUFFERS);
    
    printf("Registered Buffers:\n\r");
    printf("------------------\n\r");
    printf("ID | Name           | Size    | Swaps | Last Swap\n\r");
    printf("---+----------------+---------+-------+----------\n\r");
    
    for (int i = 0; i < count; i++) {
        printf("%-2d | %-14s | %-7lu | %-5lu | %llu us\n\r",
               buffer_info[i].id,
               buffer_info[i].info.name,
               buffer_info[i].info.buffer_size,
               buffer_info[i].info.swap_count,
               buffer_info[i].info.last_swap_time_us);
    }
    
    if (count == 0) {
        printf("No buffers registered\n\r");
    }
    
    return 0;
}

int cmd_stats_reset(int argc, char *argv[]) {
    if (argc > 1 && strcmp(argv[1], "all") == 0) {
        stats_reset();
        printf("All statistics reset\n\r");
    } else if (argc > 1 && strcmp(argv[1], "tasks") == 0) {
        stats_reset_task_timing(-1);
        printf("Task timing statistics reset\n\r");
    } else {
        printf("Usage: statreset <all|tasks>\n\r");
        return 1;
    }
   
    return 0;
}

void register_stats_commands(void) {
    for (int i = 0; i < sizeof(stats_commands) / sizeof(stats_commands[0]); i++) {
        shell_register_command(&stats_commands[i]);
    }
}
// File: ./Src/Core/Shell/usb_shell.c
/**
* @file usb_shell.c
* @brief USB Shell implementation for Raspberry Pi Pico 2W
* @author [Robert Fudge (rnfudge@mun.ca)]
* @date [Current Date]
* 
* This file implements the USB shell functionality, including command
* parsing, execution, and built-in command handlers.
*/

#include "usb_shell.h"
#include "pico/stdlib.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/**
 * @defgroup Shell_Private Private Shell Definitions
 * @{
 */

/** Maximum number of commands that can be registered */
#define MAX_COMMANDS 32

/** @} */

/**
 * @defgroup Shell_Private_Data Private Shell Data
 * @{
 */

/** Global shell context instance */
static shell_context_t shell_ctx;

/** Command table storing pointers to all registered commands */
static const shell_command_t *command_table[MAX_COMMANDS];

/** Current number of registered commands */
static uint8_t command_count = 0;

/** Built-in command definitions */
static const shell_command_t builtin_commands[] = {
    {"help", "Show available commands", cmd_help},
    {"clear", "Clear the screen", cmd_clear},
    {"echo", "Echo arguments back to console", cmd_echo},
};

/** @} */

/**
 * @defgroup Shell_Private_Functions Private Shell Functions
 * @{
 */

/**
 * @brief Process a complete command line
 * 
 * Called when user presses Enter. Parses the command buffer and
 * executes the matching command if found.
 */
static void shell_process_command(void);

/**
 * @brief Parse the command buffer into arguments
 * 
 * Tokenizes the input buffer into separate arguments, handling
 * whitespace separation. Updates shell_ctx.argc and shell_ctx.argv.
 */
static void shell_parse_buffer(void);

/**
 * @brief Print the shell prompt
 * 
 * Outputs the shell prompt string to the console.
 */
static void shell_print_prompt(void);

/** @} */

void shell_init(void) {
    //Initialize stdio for USB
    stdio_init_all();
    
    //Clear shell context
    memset(&shell_ctx, 0, sizeof(shell_ctx));
    shell_ctx.echo_enabled = true;
    
    //Register built-in commands
    for (int i = 0; i < sizeof(builtin_commands) / sizeof(builtin_commands[0]); i++) {
        shell_register_command(&builtin_commands[i]);
    }
    
    //Wait for USB connection
    while (!stdio_usb_connected()) {
        sleep_ms(100);
    }
    
    //Print welcome message
    printf("\n\rRaspberry Pi Pico 2W USB Shell\n\r");
    printf("Type 'help' for available commands\n\r");
}

void shell_task(void) {
    int c = getchar_timeout_us(0);
    
    if (c == PICO_ERROR_TIMEOUT) {
        return;
    }
    
    //Handle special characters
    switch (c) {
        case '\r':
        case '\n':
            if (shell_ctx.echo_enabled) {
                printf("\n\r");
            }
            shell_process_command();
            shell_print_prompt();
            break;
            
        case '\b':
        case 0x7F: //Delete key
            if (shell_ctx.buffer_pos > 0) {
                shell_ctx.buffer_pos--;
                shell_ctx.buffer[shell_ctx.buffer_pos] = '\0';
                if (shell_ctx.echo_enabled) {
                    printf("\b \b");
                }
            }
            break;
            
        case '\t':
            //Tab key - could implement command completion here
            break;
            
        default:
            if (shell_ctx.buffer_pos < SHELL_BUFFER_SIZE - 1) {
                shell_ctx.buffer[shell_ctx.buffer_pos++] = c;
                shell_ctx.buffer[shell_ctx.buffer_pos] = '\0';
                if (shell_ctx.echo_enabled && isprint(c)) {
                    putchar(c);
                }
            }
            break;
    }
}

bool shell_register_command(const shell_command_t *cmd) {
    if (command_count >= MAX_COMMANDS || cmd == NULL) {
        return false;
    }
    
    command_table[command_count++] = cmd;
    return true;
}

static void shell_process_command(void) {
    if (shell_ctx.buffer_pos == 0) {
        return;
    }
    
    //Parse the command buffer
    shell_parse_buffer();
    
    if (shell_ctx.argc == 0) {
        shell_ctx.buffer_pos = 0;
        shell_ctx.buffer[0] = '\0';
        return;
    }
    
    //Find and execute command
    bool found = false;
    for (int i = 0; i < command_count; i++) {
        if (strcmp(shell_ctx.argv[0], command_table[i]->command) == 0) {
            command_table[i]->handler(shell_ctx.argc, shell_ctx.argv);
            found = true;
            break;
        }
    }
    
    if (!found) {
        printf("Unknown command: %s\n\r", shell_ctx.argv[0]);
    }
    
    //Clear buffer
    shell_ctx.buffer_pos = 0;
    shell_ctx.buffer[0] = '\0';
}

static void shell_parse_buffer(void) {
    char *ptr = shell_ctx.buffer;
    shell_ctx.argc = 0;
    
    while (*ptr && shell_ctx.argc < SHELL_MAX_ARGS) {
        //Skip whitespace
        while (*ptr && isspace(*ptr)) {
            ptr++;
        }
        
        if (*ptr == '\0') {
            break;
        }
        
        //Mark start of argument
        shell_ctx.argv[shell_ctx.argc++] = ptr;
        
        //Find end of argument
        while (*ptr && !isspace(*ptr)) {
            ptr++;
        }
        
        if (*ptr) {
            *ptr++ = '\0';
        }
    }
}

static void shell_print_prompt(void) {
    printf(SHELL_PROMPT);
}

//Built-in command implementations
int cmd_help(int argc, char *argv[]) {
    printf("Available commands:\n\r");
    for (int i = 0; i < command_count; i++) {
        printf("  %-12s %s\n\r", command_table[i]->command, command_table[i]->help);
    }
    return 0;
}

int cmd_clear(int argc, char *argv[]) {
    printf("\033[2J\033[H");  //ANSI escape codes to clear screen
    return 0;
}

int cmd_echo(int argc, char *argv[]) {
    for (int i = 1; i < argc; i++) {
        printf("%s", argv[i]);
        if (i < argc - 1) {
            printf(" ");
        }
    }
    printf("\n\r");
    return 0;
}
// File: ./Src/Core/Stats/hardware_stats.c
/**
* @file hardware_stats.c
* @brief Implementation for RP2350 cache and FPU status detection
* @author Robert Fudge (rnfudge@mun.ca)
* @date 2025
* 
* This module provides functions to detect and benchmark 
* cache and FPU functionality on the RP2350 processor.
*/

#include "hardware_stats.h"
#include "pico/stdlib.h"
#include <stdio.h>

#include "hardware/structs/scb.h"

// Define cache control mask constants if not defined by SDK
#ifndef SCB_CCR_IC_Msk
#define SCB_CCR_IC_Msk (1 << 17)  // I-Cache enable bit in CCR

#endif

#ifndef SCB_CCR_DC_Msk
#define SCB_CCR_DC_Msk (1 << 16)  // D-Cache enable bit in CCR

#endif

// Flag for module initialization status
static bool initialized = false;

/**
 * @brief Initialize the cache and FPU stats module
 * 
 * @return true if initialization successful
 * @return false if initialization failed
 */
bool cache_fpu_stats_init(void) {
    // Nothing specific to initialize, just set the flag
    initialized = true;
    return true;
}

/**
 * @brief Check if FPU is enabled using runtime benchmarking
 * 
 * Since direct register access is causing issues on RP2350,
 * we'll use a benchmark approach to determine if the FPU is enabled.
 * 
 * @return true if FPU appears to be enabled based on performance
 * @return false if FPU seems disabled
 */
bool cache_fpu_is_fpu_enabled(void) {
    // Run two quick benchmarks - one with integer math, one with float
    uint32_t int_time, float_time;
    volatile int int_result = 1;
    volatile float float_result = 1.0f;
    
    // Integer benchmark
    uint32_t start_time = time_us_32();
    for(int i = 0; i < 1000; i++) {
        int_result *= 2;
        int_result /= 2;
    }
    int_time = time_us_32() - start_time;
    
    // Float benchmark  
    start_time = time_us_32();
    for(int i = 0; i < 1000; i++) {
        float_result *= 2.0f;
        float_result /= 2.0f;
    }
    float_time = time_us_32() - start_time;
    
    // If float operations are significantly faster than expected compared to int,
    // the FPU is likely enabled
    // Use compiler flag as a secondary check
    #if defined(PICO_FPU_ENABLED) && PICO_FPU_ENABLED
        return (float_time < int_time * 2);
    #else
        return false;
    #endif
}

/**
 * @brief Test if cache is enabled by performance measurement
 * 
 * @return true if cache appears to be enabled based on access patterns
 * @return false if cache seems disabled
 */
bool cache_is_cache_enabled(void) {
    // Create a large array in RAM
    #define TEST_SIZE 4096
    static volatile uint8_t test_array[TEST_SIZE];
    uint32_t uncached_time, cached_time;
    volatile uint32_t sum = 0;
    
    // Initialize array
    for (int i = 0; i < TEST_SIZE; i++) {
        test_array[i] = i & 0xFF;
    }
    
    // First pass - uncached access
    uint32_t start_time = time_us_32();
    for (int i = 0; i < TEST_SIZE; i++) {
        sum += test_array[i];
    }
    uncached_time = time_us_32() - start_time;
    
    // Second pass - should be cached if cache is enabled
    start_time = time_us_32();
    for (int i = 0; i < TEST_SIZE; i++) {
        sum += test_array[i];
    }
    cached_time = time_us_32() - start_time;
    
    // If second pass is significantly faster, cache is likely enabled
    // Use compiler flag as a secondary check
    #if defined(PICO_CACHE_ENABLED) && PICO_CACHE_ENABLED
        return (cached_time < uncached_time * 0.7);
    #else
        return false;
    #endif
}

/**
 * @brief Check if instruction cache is enabled on RP2350
 * 
 * @return true if instruction cache is enabled
 * @return false if instruction cache is disabled
 */
bool cache_fpu_is_icache_enabled(void) {
    return (scb_hw->ccr & SCB_CCR_IC_Msk) != 0;
}

/**
 * @brief Check if data cache is enabled on RP2350
 * 
 * @return true if data cache is enabled
 * @return false if data cache is disabled
 */
bool cache_fpu_is_dcache_enabled(void) {
    return (scb_hw->ccr & SCB_CCR_DC_Msk) != 0;
}

/**
 * @brief Run a benchmark to test FPU performance
 * 
 * @return Benchmark execution time in microseconds
 */
uint32_t cache_fpu_benchmark_fpu(void) {
    uint32_t start_time, end_time;
    volatile float result = 1.0f;
    
    // Get start time
    start_time = time_us_32();
    
    // Do some floating point operations
    for(int i = 0; i < 10000; i++) {
        result *= 1.000001f;
        result /= 1.000001f;
    }
    
    // Get end time
    end_time = time_us_32();
    
    // Prevent optimization from removing the calculation
    if (result != 1.0f) {
        printf("Unexpected result: %f\n", result);
    }
    
    return end_time - start_time;
}

/**
 * @brief Get estimated number of cache levels
 * 
 * @return Number of cache levels (estimated)
 */
static uint32_t get_cache_levels(void) {
    // RP2350 typically has one level of cache
    return 1;
}

/**
 * @brief Get estimated cache line sizes
 * 
 * @param icache_line_size Pointer to store instruction cache line size
 * @param dcache_line_size Pointer to store data cache line size
 */
static void get_cache_line_sizes(uint32_t* icache_line_size, uint32_t* dcache_line_size) {
    // Common cache line sizes for ARM cores
    *icache_line_size = 32;  // 32 bytes is typical
    *dcache_line_size = 32;  // 32 bytes is typical
}

/**
 * @brief Collect all cache and FPU statistics
 * 
 * @param stats Pointer to structure to store statistics
 */
void cache_fpu_get_stats(cache_fpu_stats_t* stats) {
    if (!initialized) {
        cache_fpu_stats_init();
    }
    
    // Check cache and FPU status
    stats->fpu_enabled = cache_fpu_is_fpu_enabled();
    stats->icache_enabled = cache_fpu_is_icache_enabled();
    stats->dcache_enabled = cache_fpu_is_dcache_enabled();
    
    // Run FPU benchmark
    stats->fpu_benchmark_time = cache_fpu_benchmark_fpu();
    
    // Get cache information
    stats->cache_levels = get_cache_levels();
    get_cache_line_sizes(&stats->icache_line_size, &stats->dcache_line_size);
}
// File: ./Src/Core/Stats/mem_usage.c

// File: ./Src/Core/Stats/stats.c
/**
* @file stats.c
* @brief System statistics module implementation
*/

#include "stats.h"
#include "scheduler.h"
#include "hardware/clocks.h"
#include "hardware/adc.h"
#include "hardware/vreg.h"
#include "pico/stdlib.h"
#include "pico/time.h"
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

// Private data structures
static struct {
    system_stats_t system;
    task_timing_stats_t task_timing[MAX_TASK_STATS];
    buffer_registration_t buffers[MAX_REGISTERED_BUFFERS];
    optimization_state_t active_optimizations;
    uint64_t system_start_time_us;
    uint64_t last_update_time_us;
    bool collection_enabled;
    spin_lock_t* stats_lock;
} stats_data;

// Private function declarations
static void update_system_stats(void);
static void analyze_optimizations(optimization_suggestion_t *suggestions, int max_suggestions, int *count);
static bool is_task_registered(uint32_t task_id);
static int find_task_slot(uint32_t task_id);

bool stats_init(void) {
    memset(&stats_data, 0, sizeof(stats_data));
    
    // Claim a spin lock and get its instance
    uint lock_num = spin_lock_claim_unused(true);
    if (lock_num == -1) {
        return false;
    }
    
    // Get the spin lock instance from the lock number
    stats_data.stats_lock = spin_lock_instance(lock_num);
    
    stats_data.system_start_time_us = time_us_64();
    stats_data.collection_enabled = true;
    
    // Initialize ADC for voltage/temperature monitoring
    adc_init();
    adc_set_temp_sensor_enabled(true);
    
    // Set default optimizations based on current system state
    stats_data.active_optimizations = OPT_NONE;
    
    // Check if multicore is enabled
    scheduler_stats_t sched_stats;
    if (scheduler_get_stats(&sched_stats)) {
        if (sched_stats.core1_switches > 0) {
            stats_data.active_optimizations |= OPT_MULTICORE_ENABLED;
        }
    }
    
    return true;
}

bool stats_get_system(system_stats_t *stats) {
    if (!stats) return false;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    // Update system stats
    update_system_stats();
    
    // Copy to output
    *stats = stats_data.system;
    
    spin_unlock(stats_data.stats_lock, save);
    return true;
}

static void update_system_stats(void) {
    uint64_t current_time = time_us_64();
    
    // Update system frequency
    stats_data.system.system_freq_hz = clock_get_hz(clk_sys);
    
    // Update uptime
    stats_data.system.uptime_us = current_time - stats_data.system_start_time_us;
    
    // Read temperature
    adc_select_input(4); // Temperature sensor is on ADC4
    uint16_t raw = adc_read();
    float voltage = raw * 3.3f / (1 << 12);
    stats_data.system.temperature_c = 27 - (voltage - 0.706f) / 0.001721f;
    
    // Estimate voltage (placeholder - actual implementation would need hardware support)
    stats_data.system.voltage_mv = 3300; // Default 3.3V
    
    // Current measurement would require external hardware
    stats_data.system.current_ma = 0; // Not available
    
    // Calculate CPU usage based on scheduler stats
    scheduler_stats_t sched_stats;
    if (scheduler_get_stats(&sched_stats)) {
        uint64_t period_us = current_time - stats_data.last_update_time_us;
        if (period_us > 0) {
            // Estimate CPU usage based on context switches and timing
            stats_data.system.cpu_usage_percent = 50; // Placeholder
            stats_data.system.core0_usage_percent = 50; // Placeholder
            stats_data.system.core1_usage_percent = (sched_stats.core1_switches > 0) ? 30 : 0;
        }
    }
    
    stats_data.last_update_time_us = current_time;
}

bool stats_get_task_timing(uint32_t task_id, task_timing_stats_t *stats) {
    if (!stats) return false;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    int slot = find_task_slot(task_id);
    if (slot < 0) {
        spin_unlock(stats_data.stats_lock, save);
        return false;
    }
    
    *stats = stats_data.task_timing[slot];
    
    spin_unlock(stats_data.stats_lock, save);
    return true;
}

int stats_get_all_task_timing(task_timing_stats_t *stats, int max_tasks) {
    if (!stats || max_tasks <= 0) return 0;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    int count = 0;
    for (int i = 0; i < MAX_TASK_STATS && count < max_tasks; i++) {
        if (stats_data.task_timing[i].task_id != 0) {
            stats[count++] = stats_data.task_timing[i];
        }
    }
    
    spin_unlock(stats_data.stats_lock, save);
    return count;
}

bool stats_update_task_timing(uint32_t task_id, uint32_t execution_time_us) {
    if (!stats_data.collection_enabled) return false;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    int slot = find_task_slot(task_id);
    if (slot < 0) {
        // Find empty slot
        for (int i = 0; i < MAX_TASK_STATS; i++) {
            if (stats_data.task_timing[i].task_id == 0) {
                slot = i;
                stats_data.task_timing[i].task_id = task_id;
                
                // Get task info
                task_control_block_t tcb;
                if (scheduler_get_task_info(task_id, &tcb)) {
                    strncpy(stats_data.task_timing[i].task_name, tcb.name, TASK_NAME_LEN - 1);
                }
                break;
            }
        }
    }
    
    if (slot < 0) {
        spin_unlock(stats_data.stats_lock, save);
        return false;
    }
    
    task_timing_stats_t *timing = &stats_data.task_timing[slot];
    uint64_t current_time = time_us_64();
    
    // Update execution statistics
    timing->total_executions++;
    
    if (timing->max_execution_us < execution_time_us) {
        timing->max_execution_us = execution_time_us;
    }
    
    // Update average execution time
    timing->avg_execution_us = ((timing->avg_execution_us * (timing->total_executions - 1)) + 
                               execution_time_us) / timing->total_executions;
    
    // Update period statistics
    static uint64_t last_execution_time[MAX_TASK_STATS];
    if (last_execution_time[slot] > 0) {
        uint32_t actual_period = current_time - last_execution_time[slot];
        timing->actual_period_us = actual_period;
        
        if (timing->min_period_us == 0 || timing->min_period_us > actual_period) {
            timing->min_period_us = actual_period;
        }
        
        if (timing->max_period_us < actual_period) {
            timing->max_period_us = actual_period;
        }
        
        // Calculate jitter
        if (timing->desired_period_us > 0) {
            float jitter = (float)abs((int)actual_period - (int)timing->desired_period_us) / 
                          timing->desired_period_us * 100.0f;
            timing->jitter_percent = jitter;
            
            // Check for deadline miss
            if (actual_period > timing->desired_period_us * 1.1f) {
                timing->deadline_misses++;
            }
        }
    }
    
    last_execution_time[slot] = current_time;
    
    spin_unlock(stats_data.stats_lock, save);
    return true;
}

optimization_state_t stats_get_optimizations(void) {
    return stats_data.active_optimizations;
}

bool stats_set_optimization(optimization_state_t opt, bool enabled) {
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    if (enabled) {
        stats_data.active_optimizations |= opt;
    } else {
        stats_data.active_optimizations &= ~opt;
    }
    
    spin_unlock(stats_data.stats_lock, save);
    return true;
}

int stats_get_optimization_suggestions(optimization_suggestion_t *suggestions, int max_suggestions) {
    if (!suggestions || max_suggestions <= 0) return 0;
    
    int count = 0;
    analyze_optimizations(suggestions, max_suggestions, &count);
    
    return count;
}

static void analyze_optimizations(optimization_suggestion_t *suggestions, int max_suggestions, int *count) {
    *count = 0;
    
    // Check if frequency scaling could help
    if (!(stats_data.active_optimizations & OPT_FREQUENCY_SCALING)) {
        if (stats_data.system.cpu_usage_percent > 80) {
            suggestions[(*count)++] = (optimization_suggestion_t){
                .optimization = OPT_FREQUENCY_SCALING,
                .description = "Enable frequency scaling to boost performance",
                .priority = 9,
                .expected_improvement_percent = 15.0f
            };
        }
        if (*count >= max_suggestions) return;
    }
    
    // Check if DMA could help
    if (!(stats_data.active_optimizations & OPT_DMA_ENABLED)) {
        bool has_high_throughput = false;
        for (int i = 0; i < MAX_REGISTERED_BUFFERS; i++) {
            if (stats_data.buffers[i].is_registered && 
                stats_data.buffers[i].swap_count > 100) {
                has_high_throughput = true;
                break;
            }
        }
        
        if (has_high_throughput) {
            suggestions[(*count)++] = (optimization_suggestion_t){
                .optimization = OPT_DMA_ENABLED,
                .description = "Enable DMA for high-throughput buffers",
                .priority = 8,
                .expected_improvement_percent = 20.0f
            };
        }
        if (*count >= max_suggestions) return;
    }
    
    // Check if double buffering could help
    if (!(stats_data.active_optimizations & OPT_DOUBLE_BUFFERING)) {
        int single_buffers = 0;
        for (int i = 0; i < MAX_REGISTERED_BUFFERS; i++) {
            if (stats_data.buffers[i].is_registered && 
                stats_data.buffers[i].buffer_b == NULL) {
                single_buffers++;
            }
        }
        
        if (single_buffers > 0) {
            suggestions[(*count)++] = (optimization_suggestion_t){
                .optimization = OPT_DOUBLE_BUFFERING,
                .description = "Enable double buffering for smoother data flow",
                .priority = 7,
                .expected_improvement_percent = 10.0f
            };
        }
        if (*count >= max_suggestions) return;
    }
}

int stats_register_buffer(const char *name, void *buffer_a, void *buffer_b, 
                         size_t size, volatile void **active_buffer) {
    if (!name || !buffer_a || !active_buffer || size == 0) return -1;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    // Find empty slot
    int slot = -1;
    for (int i = 0; i < MAX_REGISTERED_BUFFERS; i++) {
        if (!stats_data.buffers[i].is_registered) {
            slot = i;
            break;
        }
    }
    
    if (slot < 0) {
        spin_unlock(stats_data.stats_lock, save);
        return -1;
    }
    
    buffer_registration_t *reg = &stats_data.buffers[slot];
    reg->name = name;
    reg->buffer_a = buffer_a;
    reg->buffer_b = buffer_b;
    reg->buffer_size = size;
    reg->active_buffer = active_buffer;
    reg->swap_count = 0;
    reg->last_swap_time_us = time_us_64();
    reg->is_registered = true;
    
    spin_unlock(stats_data.stats_lock, save);
    return slot;
}

bool stats_buffer_swapped(int buffer_id) {
    if (buffer_id < 0 || buffer_id >= MAX_REGISTERED_BUFFERS) return false;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    buffer_registration_t *reg = &stats_data.buffers[buffer_id];
    if (!reg->is_registered) {
        spin_unlock(stats_data.stats_lock, save);
        return false;
    }
    
    reg->swap_count++;
    reg->last_swap_time_us = time_us_64();
    
    spin_unlock(stats_data.stats_lock, save);
    return true;
}

const char* stats_optimization_to_string(optimization_state_t opt) {
    switch (opt) {
        case OPT_FREQUENCY_SCALING: return "Frequency Scaling";
        case OPT_VOLTAGE_SCALING: return "Voltage Scaling";
        case OPT_DMA_ENABLED: return "DMA Enabled";
        case OPT_CACHE_ENABLED: return "Cache Enabled";
        case OPT_MULTICORE_ENABLED: return "Multicore Enabled";
        case OPT_INTERRUPT_COALESCING: return "Interrupt Coalescing";
        case OPT_POWER_GATING: return "Power Gating";
        case OPT_DOUBLE_BUFFERING: return "Double Buffering";
        default: return "Unknown";
    }
}

static int find_task_slot(uint32_t task_id) {
    for (int i = 0; i < MAX_TASK_STATS; i++) {
        if (stats_data.task_timing[i].task_id == task_id) {
            return i;
        }
    }
    return -1;
}

void stats_enable_collection(bool enabled) {
    stats_data.collection_enabled = enabled;
}

void stats_reset(void) {
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    // Reset system stats
    memset(&stats_data.system, 0, sizeof(system_stats_t));
    stats_data.system_start_time_us = time_us_64();
    
    // Reset task timing
    memset(stats_data.task_timing, 0, sizeof(stats_data.task_timing));
    
    // Keep buffer registrations but reset counts
    for (int i = 0; i < MAX_REGISTERED_BUFFERS; i++) {
        if (stats_data.buffers[i].is_registered) {
            stats_data.buffers[i].swap_count = 0;
            stats_data.buffers[i].last_swap_time_us = time_us_64();
        }
    }
    
    spin_unlock(stats_data.stats_lock, save);
}

void stats_reset_task_timing(int task_id) {
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    if (task_id < 0) {
        // Reset all
        memset(stats_data.task_timing, 0, sizeof(stats_data.task_timing));
    } else {
        // Reset specific task
        int slot = find_task_slot(task_id);
        if (slot >= 0) {
            uint32_t id = stats_data.task_timing[slot].task_id;
            char name[TASK_NAME_LEN];
            strncpy(name, stats_data.task_timing[slot].task_name, TASK_NAME_LEN - 1);
            
            memset(&stats_data.task_timing[slot], 0, sizeof(task_timing_stats_t));
            
            stats_data.task_timing[slot].task_id = id;
            strncpy(stats_data.task_timing[slot].task_name, name, TASK_NAME_LEN - 1);
        }
    }
    
    spin_unlock(stats_data.stats_lock, save);
}

bool stats_get_buffer_info(int buffer_id, buffer_registration_t *reg) {
    if (!reg || buffer_id < 0 || buffer_id >= MAX_REGISTERED_BUFFERS) return false;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    if (!stats_data.buffers[buffer_id].is_registered) {
        spin_unlock(stats_data.stats_lock, save);
        return false;
    }
    
    *reg = stats_data.buffers[buffer_id];
    
    spin_unlock(stats_data.stats_lock, save);
    return true;
}

int stats_get_all_buffers(buffer_registration_t *buffers, int max_buffers) {
    if (!buffers || max_buffers <= 0) return 0;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    int count = 0;
    for (int i = 0; i < MAX_REGISTERED_BUFFERS && count < max_buffers; i++) {
        if (stats_data.buffers[i].is_registered) {
            buffers[count++] = stats_data.buffers[i];
        }
    }
    
    spin_unlock(stats_data.stats_lock, save);
    return count;
}

// Add this function to stats.c
int stats_get_all_buffers_with_id(buffer_info_with_id_t *buffer_info, int max_buffers) {
    if (!buffer_info || max_buffers <= 0) return 0;
    
    uint32_t save = spin_lock_blocking(stats_data.stats_lock);
    
    int count = 0;
    for (int i = 0; i < MAX_REGISTERED_BUFFERS && count < max_buffers; i++) {
        if (stats_data.buffers[i].is_registered) {
            buffer_info[count].id = i;
            buffer_info[count].info = stats_data.buffers[i];
            count++;
        }
    }
    
    spin_unlock(stats_data.stats_lock, save);
    return count;
}